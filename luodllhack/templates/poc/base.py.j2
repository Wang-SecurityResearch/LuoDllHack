#!/usr/bin/env python3
"""
LuoDllHack Auto-Generated PoC
{% block description %}{{ description }}{% endblock %}

Target: {{ dll_name }}
Function: {{ func_name }} @ {{ func_addr | hex }}
Vulnerability: {{ vuln_type }}
Generated by LuoDllHack Framework
"""

import ctypes
from ctypes import wintypes
import struct
import sys
import os
import json
import re

# =============================================================================
# Utility Functions
# =============================================================================

def check_dll_arch(dll_path):
    """检查 DLL 架构并与当前 Python 匹配"""
    try:
        with open(dll_path, 'rb') as f:
            if f.read(2) != b'MZ':
                return None, "Not a valid PE file"
            f.seek(0x3C)
            pe_offset = struct.unpack('<I', f.read(4))[0]
            f.seek(pe_offset)
            if f.read(4) != b'PE\x00\x00':
                return None, "Invalid PE signature"
            machine = struct.unpack('<H', f.read(2))[0]
            dll_arch = "x64" if machine == 0x8664 else "x86" if machine == 0x14c else "unknown"
            return dll_arch, None
    except Exception as e:
        return None, str(e)

def get_python_arch():
    """获取当前 Python 架构"""
    return "x64" if sys.maxsize > 2**32 else "x86"

def verify_arch(dll_path):
    """验证架构兼容性"""
    py_arch = get_python_arch()
    dll_arch, err = check_dll_arch(dll_path)
    if err:
        print(f"[!] Cannot check DLL: {err}")
        return True  # 继续执行
    if dll_arch and dll_arch != py_arch:
        print(f"[!] Architecture mismatch: DLL is {dll_arch}, Python is {py_arch}")
        print(f"[!] Please use {dll_arch} Python to run this PoC")
        return False
    print(f"[+] Architecture OK: {py_arch}")
    return True


class CrashAnalyzer:
    """
    崩溃分析器 - 用于检测误报

    记录传入的参数值，分析崩溃地址是否等于参数值。
    如果崩溃地址 = 传入的参数值，说明是签名错误导致的崩溃，不是真正的漏洞。
    """

    def __init__(self):
        self.passed_values = []  # 记录传入的参数值
        self.passed_pointers = []  # 记录传入的指针地址

    def record_arg(self, arg, is_pointer=False):
        """记录传入的参数"""
        try:
            if isinstance(arg, ctypes.c_void_p):
                val = arg.value or 0
                self.passed_pointers.append(val)
                self.passed_values.append(val)
            elif isinstance(arg, (ctypes.c_int64, ctypes.c_int32, ctypes.c_uint64, ctypes.c_uint32)):
                val = arg.value
                self.passed_values.append(val)
            elif isinstance(arg, int):
                self.passed_values.append(arg)
            elif arg is None:
                self.passed_values.append(0)
        except:
            pass

    def record_args(self, args):
        """记录所有参数"""
        for arg in args:
            self.record_arg(arg)

    def analyze_crash(self, error_msg):
        """
        分析崩溃信息，判断是否为误报

        Returns:
            dict: {
                'is_false_positive': bool,
                'crash_address': int or None,
                'matched_arg_value': int or None,
                'reason': str
            }
        """
        result = {
            'is_false_positive': False,
            'crash_address': None,
            'matched_arg_value': None,
            'reason': 'unknown'
        }

        # 从错误信息中提取崩溃地址
        # 常见格式: "access violation reading 0x00000000CAFEBABE"
        # 或: "exception: access violation reading 0xFFFFFFFFFFFFFFFF"
        patterns = [
            r'reading\s+(0x[0-9A-Fa-f]+)',
            r'writing\s+(0x[0-9A-Fa-f]+)',
            r'at\s+address\s+(0x[0-9A-Fa-f]+)',
            r'address\s+(0x[0-9A-Fa-f]+)',
        ]

        crash_addr = None
        for pattern in patterns:
            match = re.search(pattern, str(error_msg), re.IGNORECASE)
            if match:
                try:
                    crash_addr = int(match.group(1), 16)
                    break
                except ValueError:
                    pass

        if crash_addr is None:
            result['reason'] = 'no_crash_address_found'
            return result

        result['crash_address'] = crash_addr

        # 检查崩溃地址是否等于传入的参数值
        for val in self.passed_values:
            if val == 0:
                continue  # 跳过 NULL
            # 检查完全匹配或低32位匹配
            if crash_addr == val or (crash_addr & 0xFFFFFFFF) == (val & 0xFFFFFFFF):
                result['is_false_positive'] = True
                result['matched_arg_value'] = val
                result['reason'] = 'crash_address_equals_passed_argument'
                return result

        # 检查常见的"魔法值"崩溃 (0xCAFEBABE, 0xDEADBEEF, 0x41414141 等)
        magic_values = [0xCAFEBABE, 0xDEADBEEF, 0x41414141, 0xBAADF00D, 0xFEEDFACE]
        crash_low32 = crash_addr & 0xFFFFFFFF
        if crash_low32 in magic_values:
            result['is_false_positive'] = True
            result['matched_arg_value'] = crash_low32
            result['reason'] = 'crash_at_magic_value'
            return result

        # 检查崩溃地址是否为 -1 (0xFFFFFFFFFFFFFFFF)
        if crash_addr == 0xFFFFFFFFFFFFFFFF or crash_addr == 0xFFFFFFFF:
            result['is_false_positive'] = True
            result['matched_arg_value'] = -1
            result['reason'] = 'crash_at_invalid_handle'
            return result

        result['reason'] = 'genuine_crash'
        return result

    def print_analysis(self, error_msg):
        """打印崩溃分析结果"""
        analysis = self.analyze_crash(error_msg)

        print("\n" + "=" * 60)
        print("[CRASH ANALYSIS]")
        print("=" * 60)

        if analysis['crash_address']:
            print(f"Crash Address: 0x{analysis['crash_address']:X}")
        print(f"Passed Values: {[hex(v) if isinstance(v, int) else v for v in self.passed_values]}")

        if analysis['is_false_positive']:
            print(f"\n[!] FALSE POSITIVE DETECTED")
            print(f"    Reason: {analysis['reason']}")
            if analysis['matched_arg_value'] is not None:
                print(f"    Matched Arg: 0x{analysis['matched_arg_value']:X}")
            print(f"\n    This crash is likely due to incorrect function signature,")
            print(f"    not a genuine vulnerability.")
        else:
            print(f"\n[+] Crash appears genuine (not a signature error)")

        # 输出 JSON 供验证器解析
        print(f"\n[ANALYSIS_JSON]{json.dumps(analysis)}[/ANALYSIS_JSON]")
        print("=" * 60)

        return analysis


class ArgBuilder:
    """参数构建器 - 根据签名信息构建正确的函数调用参数"""

    def __init__(self, arg_count, args_info=None):
        """
        Args:
            arg_count: 参数数量
            args_info: 参数信息列表 [{'is_pointer': bool, 'type': str, ...}, ...]
        """
        self.arg_count = arg_count or 1
        self.args_info = args_info or []
        self.buffers = []
        self.crash_analyzer = CrashAnalyzer()
        # 预分配缓冲区
        for i in range(max(self.arg_count, 4)):
            self.buffers.append(ctypes.create_string_buffer(1024))

    def is_pointer_arg(self, idx):
        """检查指定参数是否为指针"""
        if idx < len(self.args_info):
            info = self.args_info[idx]
            return info.get('is_pointer', False) or '*' in info.get('type', '')
        return False

    def get_buffer_ptr(self, idx):
        """获取指定索引的缓冲区指针"""
        return ctypes.cast(self.buffers[idx % len(self.buffers)], ctypes.c_void_p)

    def build(self, payload=None, payload_arg_idx=0):
        """
        构建函数调用参数

        Args:
            payload: 要传递的 payload (可以是 bytes, int, 或其他)
            payload_arg_idx: payload 应该放在哪个参数位置

        Returns:
            参数列表
        """
        args = []
        for i in range(self.arg_count):
            if i == payload_arg_idx and payload is not None:
                # 这是 payload 参数
                if isinstance(payload, bytes):
                    buf = ctypes.create_string_buffer(payload)
                    self.buffers.append(buf)  # 保持引用
                    arg = ctypes.cast(buf, ctypes.c_void_p)
                elif isinstance(payload, int):
                    arg = ctypes.c_int64(payload)
                else:
                    arg = payload
                args.append(arg)
            elif self.is_pointer_arg(i):
                # 指针参数 - 传递有效缓冲区
                args.append(self.get_buffer_ptr(i))
            else:
                # 整数参数 - 使用安全值
                args.append(ctypes.c_int64(0))

        # 记录参数供崩溃分析
        self.crash_analyzer.record_args(args)
        return args

    def analyze_crash(self, error_msg):
        """分析崩溃，返回是否为误报"""
        return self.crash_analyzer.print_analysis(error_msg)


# =============================================================================
# Configuration
# =============================================================================

DLL_PATH = r"{{ dll_path }}"
ARG_COUNT = {{ arg_count or 1 }}
{% if args_info %}
ARGS_INFO = {{ args_info }}
{% else %}
ARGS_INFO = []
{% endif %}

# COM 方法标记
IS_COM_METHOD = {% if is_com_method %}True{% else %}False{% endif %}

HAS_THIS_POINTER = {% if has_this_pointer %}True{% else %}False{% endif %}

{% block config %}{% endblock %}

# =============================================================================
# Payload
# =============================================================================
{% block payload %}
payload = b'A' * 256
{% endblock %}

# =============================================================================
# Exploit
# =============================================================================

def exploit():
    """{% block exploit_doc %}Execute exploit{% endblock %}"""
    # 初始化参数构建器 (在函数外部以便异常处理时访问)
    global arg_builder
    arg_builder = ArgBuilder(ARG_COUNT, ARGS_INFO)

    try:
        if not verify_arch(DLL_PATH):
            return False

        # COM 方法警告
        if IS_COM_METHOD:
            print("[!] WARNING: This appears to be a COM interface method.")
            print("[!] COM methods cannot be called directly via ctypes.CDLL!")
            print("[!] Proper COM calling requires:")
            print("    1. CoCreateInstance to create COM object")
            print("    2. QueryInterface to get interface pointer")
            print("    3. Call through vtable using interface pointer")
            print("[!] The following direct call will likely crash due to signature mismatch,")
            print("    not because of a real vulnerability.")
            print("")

        print(f"[*] Loading {DLL_PATH}")
        dll = ctypes.CDLL(DLL_PATH)

        func = getattr(dll, "{{ func_name }}", None)
        if func is None:
            print("[!] Function {{ func_name }} not found")
            return False

{% if has_signature %}
        # 配置函数签名 (自动提取)
{% if ctypes_argtypes and ctypes_argtypes != 'None' %}
        func.argtypes = {{ ctypes_argtypes }}
{% endif %}
{% if ctypes_restype and ctypes_restype != 'None' %}
        func.restype = {{ ctypes_restype }}
{% endif %}
        print(f"[*] Target: {{ func_name }} @ RVA {{ func_addr | hex }} ({{ calling_convention | default('unknown') }})")
{% else %}
        print(f"[*] Target: {{ func_name }} @ {{ func_addr | hex }}")
{% endif %}

{% block exploit_body %}
        print("[*] Triggering...")
        args = arg_builder.build(payload, payload_arg_idx=0)
        result = func(*args)
        print(f"[+] Function returned: {result}")
{% endblock %}
        return True

    except OSError as e:
        error_msg = str(e)
        if "193" in error_msg or "not a valid Win32" in error_msg:
            print("[!] Architecture mismatch - use matching Python version")
        else:
            print(f"[!] OS Error: {e}")
            # 分析崩溃是否为误报
            arg_builder.analyze_crash(error_msg)
        return False
    except Exception as e:
        print(f"[*] Exception: {type(e).__name__}: {e}")
        # 分析崩溃是否为误报
        arg_builder.analyze_crash(str(e))
        return True  # Exception might indicate successful trigger

# =============================================================================
# Entry Point
# =============================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("[*] LuoDllHack {{ vuln_type }} PoC")
    print(f"[*] Target: {{ dll_name }}!{{ func_name }}")
    print("=" * 60)
    exploit()
