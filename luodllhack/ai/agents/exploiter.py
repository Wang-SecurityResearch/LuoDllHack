# -*- coding: utf-8 -*-
"""
luodllhack/ai/agents/exploiter.py
Exploitation Agent - Responsible for PoC generation and vulnerability exploitation

Responsibilities:
    - Solve for inputs using symbolic execution
    - PoC code generation
    - Formulation of exploitation strategies
    - [P3] Payload optimization driven by LLM
"""

from typing import Dict, List, Any, Optional
import logging
import json

from .base import (
    BaseAgent,
    AgentCapability,
    TaskAssignment,
    AgentResult,
)
from .prompt_engineering import OPTIMIZE_PAYLOAD_TEMPLATE, EXPLOIT_STRATEGY_TEMPLATE

logger = logging.getLogger(__name__)



class ExploiterAgent(BaseAgent):
    """
    Exploitation Agent

    Focuses on generating PoC code and vulnerability exploitation.

    Capabilities:
        - EXPLOITATION: Vulnerability exploitation

    Handled task types:
        - generate_poc: Generate PoC code
        - symbolic_explore: Explore using symbolic execution
        - craft_payload: Construct payload
        - solve_constraints: Solve constraints
    """

    def __init__(self, agent_id: str, *args, **kwargs):
        capabilities = kwargs.pop("capabilities", [AgentCapability.EXPLOITATION])

        # Extract agent_registry (BaseAgent does not accept this parameter)
        self.agent_registry = kwargs.pop("agent_registry", None)

        super().__init__(
            agent_id=agent_id,
            capabilities=capabilities,
            *args,
            **kwargs
        )

        self._task_handlers = {
            "generate_poc": self._generate_poc,
            "symbolic_explore": self._symbolic_explore,
            "craft_payload": self._craft_payload,
            "solve_constraints": self._solve_constraints,
            # [P3] LLM-driven tasks
            "llm_optimize_payload": self._llm_optimize_payload,
            "llm_plan_strategy": self._llm_plan_strategy,
            "regenerate_poc": self._regenerate_poc,
        }

        self._task_confidence = {
            "generate_poc": 0.95,
            "symbolic_explore": 0.90,
            "craft_payload": 0.85,
            "solve_constraints": 0.88,
            "llm_optimize_payload": 0.88,
            "llm_plan_strategy": 0.85,
            "regenerate_poc": 0.90,
            "auto_exploit": 0.90,
            "interactive_poc": 0.90,
        }
        
        # Register tools needed for ReAct mode
        self.register_tool_for_llm(
            "generate_pattern",
            "Generate a cyclic pattern for offset calculation",
            {"length": "Length of the pattern"}
        )
        self.register_tool_for_llm(
            "parse_crash_dump",
            "Analyze a crash dump to find EIP/RIP offset",
            {"dump_path": "Path to crash dump file"}
        )
        self.register_tool_for_llm(
            "generate_shellcode",
            "Generate shellcode for a specific payload type",
            {"os": "Target OS (windows/linux)", "arch": "x86/x64", "type": "exec/reverse_tcp"}
        )
        
        # Map complex exploitation tasks to ReAct handlers
        self._task_handlers["auto_exploit"] = self.process_task_with_react
        self._task_handlers["interactive_poc"] = self.process_task_with_react

    @property
    def role(self) -> str:
        return "exploiter"

    def can_handle(self, task: TaskAssignment) -> float:
        return self._task_confidence.get(task.task_type, 0.0)

    def process_task(self, task: TaskAssignment) -> AgentResult:
        handler = self._task_handlers.get(task.task_type)
        if handler:
            return handler(task)

        return AgentResult(
            task_id=task.task_id,
            agent_id=self.agent_id,
            success=False,
            error=f"Unknown task type: {task.task_type}"
        )

    # =========================================================================
    # Task Handlers
    # =========================================================================

    def _generate_poc(self, task: TaskAssignment) -> AgentResult:
        """
        Generate PoC code

        Try symbolic execution for precise inputs first, then generate PoC.
        """
        finding = task.parameters.get("finding", {})
        vuln_type = task.parameters.get("vuln_type") or finding.get("vuln_type", "buffer_overflow")
        address = task.parameters.get("address") or finding.get("address")
        function = task.parameters.get("function") or finding.get("function", "")
        finding_id = task.parameters.get("finding_id")

        if not address and not function:
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=False,
                error="Missing address or function parameter"
            )

        artifacts = {}
        next_tasks = []

        # Try symbolic execution for precise inputs
        solved_inputs = None
        func_address = task.parameters.get("func_address")

        if func_address and address:
            sym_result = self.call_tool("symbolic_explore", {
                "func_address": func_address,
                "target_sink_address": address,
                "num_args": 4
            })

            if sym_result and sym_result.status.value == "success" and sym_result.data:
                solved_inputs = sym_result.data.get("solved_inputs")
                artifacts["symbolic_result"] = sym_result.data

        # Generate PoC
        poc_result = self.call_tool("generate_poc", {
            "vuln_type": vuln_type,
            "target_export": function,
            "sink_address": address,
            "payload_hint": task.parameters.get("payload_hint", "")
        })

        poc_code = None
        if poc_result and poc_result.status.value == "success" and poc_result.data:
            poc_code = poc_result.data.get("poc_code")
            artifacts["poc_code"] = poc_code
            artifacts["poc_metadata"] = {
                "vuln_type": vuln_type,
                "target_export": function,
                "has_symbolic_input": solved_inputs is not None,
            }

            # Generate verification task
            if poc_code:
                next_tasks.append(TaskAssignment.create(
                    task_type="validate_poc",
                    parameters={
                        "poc_code": poc_code,
                        "finding_id": finding_id,
                    },
                    priority=6
                ))

                # Update shared state
                if finding_id:
                    self.shared_state.update_finding(
                        finding_id,
                        poc_code=poc_code,
                        status="exploited"
                    )

                # Phase 2: Use communication protocol to broadcast PoC generation completion
                self.send_collaboration_request(
                    request_type="broadcast_disc",
                    payload={
                        "discovery_type": "poc_generated",
                        "finding_id": finding_id,
                        "vuln_type": vuln_type,
                        "function": function,
                    },
                    target_agent=None  # Broadcast to all Agents
                )

        success = poc_code is not None
        return AgentResult(
            task_id=task.task_id,
            agent_id=self.agent_id,
            success=success,
            artifacts=artifacts,
            next_tasks=next_tasks,
            metadata={
                "poc_generated": success,
                "has_symbolic_input": solved_inputs is not None,
            },
            error=None if success else "Failed to generate PoC"
        )

    def _symbolic_explore(self, task: TaskAssignment) -> AgentResult:
        """
        Symbolic execution exploration

        Use symbolic execution to explore paths to the target sink.
        """
        func_address = task.parameters.get("func_address")
        sink_address = task.parameters.get("sink_address")
        num_args = task.parameters.get("num_args", 4)

        if not func_address or not sink_address:
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=False,
                error="Missing func_address or sink_address parameter"
            )

        result = self.call_tool("symbolic_explore", {
            "func_address": func_address,
            "target_sink_address": sink_address,
            "num_args": num_args
        })

        if result and result.status.value == "success" and result.data:
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=True,
                artifacts={
                    "symbolic_result": result.data,
                    "solved_inputs": result.data.get("solved_inputs"),
                    "paths_found": result.data.get("paths_found", 0),
                },
                metadata={
                    "has_solution": result.data.get("solved_inputs") is not None,
                }
            )

        return AgentResult(
            task_id=task.task_id,
            agent_id=self.agent_id,
            success=False,
            error=result.error if result else "Symbolic exploration failed"
        )

    def _craft_payload(self, task: TaskAssignment) -> AgentResult:
        """
        Construct payload

        Construct appropriate payload based on vulnerability type.
        """
        vuln_type = task.parameters.get("vuln_type", "buffer_overflow")
        buffer_size = task.parameters.get("buffer_size", 256)
        target_address = task.parameters.get("target_address")

        payload = None
        payload_info = {}

        if vuln_type == "buffer_overflow":
            # Generate overflow payload
            payload = "A" * buffer_size + "B" * 8  # Simple example
            payload_info = {
                "type": "overflow",
                "padding_size": buffer_size,
                "overflow_pattern": "0x42424242",
            }

        elif vuln_type == "format_string":
            payload = "%x" * 10 + "%n"
            payload_info = {
                "type": "format_string",
                "format_specifiers": 11,
            }

        elif vuln_type == "command_injection":
            payload = "; whoami"
            payload_info = {
                "type": "command_injection",
                "command": "whoami",
            }

        return AgentResult(
            task_id=task.task_id,
            agent_id=self.agent_id,
            success=payload is not None,
            artifacts={
                "payload": payload,
                "payload_info": payload_info,
            }
        )

    def _solve_constraints(self, task: TaskAssignment) -> AgentResult:
        """
        Solve constraints

        Use solve_input tool to solve for input that triggers the vulnerability.
        """
        source_addr = task.parameters.get("source_addr")
        sink_addr = task.parameters.get("sink_addr")

        if not source_addr or not sink_addr:
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=False,
                error="Missing source_addr or sink_addr parameter"
            )

        result = self.call_tool("solve_input", {
            "source_addr": source_addr,
            "sink_addr": sink_addr
        })

        if result and result.status.value == "success" and result.data:
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=True,
                artifacts={
                    "solved_input": result.data,
                }
            )

        return AgentResult(
            task_id=task.task_id,
            agent_id=self.agent_id,
            success=False,
            error=result.error if result else "Constraint solving failed"
        )

    # =========================================================================
    # [P3] LLM-driven tasks
    # =========================================================================

    def _llm_optimize_payload(self, task: TaskAssignment) -> AgentResult:
        """
        Optimize payload using LLM

        LLM analyzes the current payload and provides optimization suggestions.
        """
        vuln_type = task.parameters.get("vuln_type", "buffer_overflow")
        function = task.parameters.get("function", "unknown")
        buffer_size = task.parameters.get("buffer_size", 256)
        arch = task.parameters.get("arch", "x64")
        bad_chars = task.parameters.get("bad_chars", [])
        current_payload = task.parameters.get("payload", "")

        if isinstance(current_payload, bytes):
            current_payload = current_payload.hex()

        # Check if LLM is available
        if self.llm_pool is None:
            logger.warning(f"Agent {self.agent_id} has no LLM for payload optimization")
            return self._craft_payload(task)

        # Build prompt
        # Build prompt
        prompt = OPTIMIZE_PAYLOAD_TEMPLATE.format(
            vuln_type=vuln_type,
            function=function,
            buffer_size=buffer_size,
            arch=arch,
            bad_chars=bad_chars if bad_chars else "none detected",
            current_payload=current_payload[:500] if current_payload else "none",
        )

        try:
            response = self.call_llm(prompt)
            if response is None or response.text is None:
                logger.warning("LLM returned empty response for payload optimization")
                return self._craft_payload(task)

            # Parse response
            llm_result = self._parse_json_response(response.text)
            if llm_result is None:
                logger.warning("Failed to parse LLM payload optimization response")
                return self._craft_payload(task)

            optimized_payload = None
            if llm_result.get("optimized_payload_hex"):
                try:
                    optimized_payload = bytes.fromhex(llm_result["optimized_payload_hex"])
                except ValueError:
                    pass

            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=True,
                artifacts={
                    "llm_optimization": llm_result,
                    "optimized_payload": optimized_payload.hex() if optimized_payload else None,
                    "original_payload": current_payload,
                },
                metadata={
                    "llm_optimized": True,
                    "confidence": llm_result.get("confidence", 0.5),
                    "has_optimized_payload": optimized_payload is not None,
                }
            )

        except Exception as e:
            logger.error(f"LLM payload optimization failed: {e}")
            return self._craft_payload(task)

    def _llm_plan_strategy(self, task: TaskAssignment) -> AgentResult:
        """
        Plan exploitation strategy using LLM

        LLM analyzes the vulnerability and plans the best exploitation strategy.
        """
        vuln_type = task.parameters.get("vuln_type", "buffer_overflow")
        function = task.parameters.get("function", "unknown")
        address = task.parameters.get("address", "unknown")
        confidence = task.parameters.get("confidence", 0.5)
        tainted_args = task.parameters.get("tainted_args", [])
        sink_api = task.parameters.get("sink_api", "unknown")
        buffer_size = task.parameters.get("buffer_size", 256)

        # Check if LLM is available
        if self.llm_pool is None:
            logger.warning(f"Agent {self.agent_id} has no LLM for strategy planning")
            # Return default strategy
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=True,
                artifacts={
                    "strategy": {
                        "strategy": "default buffer overflow exploitation",
                        "exploitation_type": "stack_overflow",
                        "payload_structure": {
                            "padding_size": buffer_size,
                            "control_offset": buffer_size + 8,
                            "payload_type": "pattern"
                        },
                        "mitigations_to_consider": ["DEP", "ASLR"],
                        "testing_steps": ["Generate pattern", "Trigger crash", "Calculate offset"],
                        "confidence": 0.5
                    }
                },
                metadata={"llm_planned": False}
            )

        # Build prompt
        # Build prompt
        prompt = EXPLOIT_STRATEGY_TEMPLATE.format(
            vuln_type=vuln_type,
            function=function,
            address=address,
            confidence=confidence,
            tainted_args=tainted_args,
            sink_api=sink_api,
            buffer_size=buffer_size,
        )

        try:
            response = self.call_llm(prompt)
            if response is None or response.text is None:
                logger.warning("LLM returned empty response for strategy planning")
                return AgentResult(
                    task_id=task.task_id,
                    agent_id=self.agent_id,
                    success=False,
                    error="LLM returned empty response"
                )

            # Parse response
            strategy = self._parse_json_response(response.text)
            if strategy is None:
                return AgentResult(
                    task_id=task.task_id,
                    agent_id=self.agent_id,
                    success=False,
                    error="Failed to parse LLM strategy response"
                )

            # Generate follow-up tasks based on strategy
            next_tasks = []
            if strategy.get("payload_structure"):
                next_tasks.append(TaskAssignment.create(
                    task_type="craft_payload",
                    parameters={
                        "vuln_type": vuln_type,
                        "buffer_size": strategy["payload_structure"].get("padding_size", buffer_size),
                        "target_address": address,
                    },
                    priority=7
                ))

            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=True,
                artifacts={"strategy": strategy},
                next_tasks=next_tasks,
                metadata={
                    "llm_planned": True,
                    "exploitation_type": strategy.get("exploitation_type"),
                    "confidence": strategy.get("confidence", 0.5),
                }
            )

        except Exception as e:
            logger.error(f"LLM strategy planning failed: {e}")
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=False,
                error=f"Strategy planning failed: {str(e)}"
            )

    def _regenerate_poc(self, task: TaskAssignment) -> AgentResult:
        """
        Regenerate PoC based on LLM review feedback

        Improve PoC by incorporating feedback from CriticAgent.
        """
        finding_id = task.parameters.get("finding_id")
        issues = task.parameters.get("issues", [])
        improvements = task.parameters.get("improvements", [])

        if not finding_id:
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=False,
                error="Missing finding_id for PoC regeneration"
            )

        # Get original finding information
        finding = self.shared_state.get_finding(finding_id)
        if not finding:
            return AgentResult(
                task_id=task.task_id,
                agent_id=self.agent_id,
                success=False,
                error=f"Finding not found: {finding_id}"
            )

        # Regenerate PoC using improvement suggestions
        # Build enhanced parameters
        enhanced_params = {
            "vuln_type": finding.vuln_type,
            "target_export": finding.function,
            "sink_address": finding.address,
            "llm_issues": issues,
            "llm_improvements": improvements,
        }

        # Call generate_poc tool
        poc_result = self.call_tool("generate_poc", {
            "vuln_type": finding.vuln_type,
            "target_export": finding.function,
            "sink_address": str(finding.address) if finding.address else None,
            "payload_hint": "",  # Let the tool decide automatically
        })

        if poc_result and poc_result.status.value == "success" and poc_result.data:
            new_poc = poc_result.data.get("poc_code")

            if new_poc:
                # Update finding
                self.shared_state.update_finding(
                    finding_id,
                    poc_code=new_poc,
                    poc_regenerated=True,
                    regeneration_reason=issues[:3] if issues else ["LLM review feedback"]
                )

                return AgentResult(
                    task_id=task.task_id,
                    agent_id=self.agent_id,
                    success=True,
                    artifacts={
                        "new_poc_code": new_poc,
                        "addressed_issues": issues,
                        "applied_improvements": improvements,
                    },
                    metadata={
                        "poc_regenerated": True,
                        "finding_id": finding_id,
                    }
                )

        return AgentResult(
            task_id=task.task_id,
            agent_id=self.agent_id,
            success=False,
            error="Failed to regenerate PoC"
        )

    def _parse_json_response(self, response_text: str) -> Optional[Dict]:
        """Parse JSON from LLM response"""
        import re

        # Try parsing directly
        try:
            return json.loads(response_text)
        except json.JSONDecodeError:
            pass

        # Try extracting JSON block
        json_match = re.search(r'\{[\s\S]*\}', response_text)
        if json_match:
            try:
                return json.loads(json_match.group())
            except json.JSONDecodeError:
                pass

        return None
