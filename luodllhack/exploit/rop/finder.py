# -*- coding: utf-8 -*-
"""
luodllhack/exploit/rop/finder.py - ROP Gadget 搜索器

自动搜索二进制文件中的 ROP gadgets，用于 DEP 绕过。

修复点 (相比 exp_gen.py):
1. 添加 LRU 缓存避免重复搜索
2. Gadget 去重
3. 过滤包含 call/jmp 的无效 gadget
4. 优化搜索效率

使用示例:
    finder = ROPGadgetFinder()

    # 搜索所有 gadgets
    gadgets = finder.find_gadgets('target.dll')

    # 搜索特定类型
    pop_eax = finder.find_pop_reg('target.dll', 'eax')
    jmp_esp = finder.find_jmp_reg('target.dll', 'esp')
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Tuple
from functools import lru_cache
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

# 可选依赖
try:
    import capstone
    HAVE_CAPSTONE = True
except ImportError:
    HAVE_CAPSTONE = False
    logger.warning("Capstone not available. Install with: pip install capstone")

try:
    import pefile
    HAVE_PEFILE = True
except ImportError:
    HAVE_PEFILE = False
    logger.warning("pefile not available. Install with: pip install pefile")


@dataclass
class Gadget:
    """ROP Gadget 信息"""
    address: int                      # 绝对地址
    instructions: str                 # 指令字符串 (e.g., "pop eax ; ret")
    raw_bytes: bytes                  # 原始字节
    gadget_type: str                  # 类型: pop-ret, mov-ret, xchg-ret, jmp-reg, etc.
    registers: List[str] = field(default_factory=list)  # 涉及的寄存器
    size: int = 0                     # gadget 大小

    def __post_init__(self):
        self.size = len(self.raw_bytes)

    def __hash__(self):
        # 用于去重
        return hash((self.address, self.instructions))

    def __eq__(self, other):
        if not isinstance(other, Gadget):
            return False
        return self.address == other.address and self.instructions == other.instructions


class ROPGadgetFinder:
    """
    ROP Gadget 搜索器

    使用 Capstone 反汇编引擎搜索可用的 ROP gadgets。
    """

    # 无效指令 (会破坏控制流)
    INVALID_MNEMONICS = {
        'call',   # 会改变返回地址
        'jmp',    # 除非是 jmp reg 用于控制转移
        'int',    # 中断
        'syscall', 'sysenter',  # 系统调用
        'leave',  # 可能破坏栈帧 (某些情况下可用)
    }

    # 有效的 jmp reg 模式 (用于栈转移)
    VALID_JMP_REGS = {'esp', 'rsp', 'eax', 'rax', 'ebx', 'rbx', 'ecx', 'rcx', 'edx', 'rdx'}

    def __init__(self, arch: str = None):
        """
        初始化 Gadget 搜索器

        Args:
            arch: 架构 ('x86' 或 'x64')，如果为 None 则自动检测
        """
        self.arch = arch
        self._cache: Dict[str, List[Gadget]] = {}

        if not HAVE_CAPSTONE:
            raise RuntimeError("Capstone is required. Install with: pip install capstone")
        if not HAVE_PEFILE:
            raise RuntimeError("pefile is required. Install with: pip install pefile")

    def _get_capstone_mode(self, pe) -> Tuple:
        """根据 PE 文件确定 Capstone 模式"""
        machine = pe.FILE_HEADER.Machine

        if machine == 0x014c:  # IMAGE_FILE_MACHINE_I386
            return capstone.CS_ARCH_X86, capstone.CS_MODE_32, 'x86'
        elif machine == 0x8664:  # IMAGE_FILE_MACHINE_AMD64
            return capstone.CS_ARCH_X86, capstone.CS_MODE_64, 'x64'
        else:
            raise ValueError(f"Unsupported machine type: 0x{machine:x}")

    def find_gadgets(self,
                     binary_path: str,
                     max_gadget_len: int = 6,
                     max_gadgets: int = 10000,
                     bad_chars: List[int] = None) -> List[Gadget]:
        """
        搜索所有 ROP Gadgets

        Args:
            binary_path: 二进制文件路径
            max_gadget_len: 最大 gadget 指令数
            max_gadgets: 最大返回数量
            bad_chars: 排除包含这些字节的 gadget

        Returns:
            Gadget 列表
        """
        # 检查缓存
        cache_key = f"{binary_path}:{max_gadget_len}"
        if cache_key in self._cache:
            gadgets = self._cache[cache_key]
            if bad_chars:
                gadgets = self._filter_bad_chars(gadgets, bad_chars)
            return gadgets[:max_gadgets]

        try:
            pe = pefile.PE(binary_path)
            cs_arch, cs_mode, arch = self._get_capstone_mode(pe)
            self.arch = arch

            md = capstone.Cs(cs_arch, cs_mode)
            md.detail = True

            gadgets_set: Set[Gadget] = set()
            image_base = pe.OPTIONAL_HEADER.ImageBase

            # 遍历可执行节
            for section in pe.sections:
                if not (section.Characteristics & 0x20000000):  # IMAGE_SCN_MEM_EXECUTE
                    continue

                section_data = section.get_data()
                section_va = section.VirtualAddress

                # 搜索 RET 指令位置
                ret_positions = self._find_ret_positions(section_data, arch)

                for ret_pos in ret_positions:
                    # 从 RET 向前搜索
                    for back_offset in range(1, min(20, ret_pos + 1)):  # 最多向前 20 字节
                        start_pos = ret_pos - back_offset
                        code = section_data[start_pos:ret_pos + 1 + (1 if arch == 'x64' else 0)]

                        if len(code) < 1:
                            continue

                        # 反汇编
                        address = image_base + section_va + start_pos
                        try:
                            insns = list(md.disasm(code, address))
                        except:
                            continue

                        if not insns:
                            continue

                        # 验证 gadget
                        gadget = self._validate_gadget(insns, code[:sum(i.size for i in insns)], max_gadget_len)
                        if gadget:
                            gadgets_set.add(gadget)

                            if len(gadgets_set) >= max_gadgets * 2:  # 收集更多用于去重后筛选
                                break

            # 转换为列表并排序
            gadgets = sorted(list(gadgets_set), key=lambda g: (g.gadget_type, g.address))

            # 缓存结果
            self._cache[cache_key] = gadgets

            logger.info(f"Found {len(gadgets)} gadgets in {binary_path}")

            if bad_chars:
                gadgets = self._filter_bad_chars(gadgets, bad_chars)

            return gadgets[:max_gadgets]

        except Exception as e:
            logger.error(f"Failed to find gadgets: {e}")
            return []

    def _find_ret_positions(self, data: bytes, arch: str) -> List[int]:
        """查找所有 RET 指令位置"""
        positions = []

        # RET 操作码
        ret_opcodes = [
            0xC3,  # ret
            0xC2,  # ret imm16
            0xCB,  # retf
            0xCA,  # retf imm16
        ]

        for i, b in enumerate(data):
            if b in ret_opcodes:
                positions.append(i)

        return positions

    def _validate_gadget(self,
                         insns: list,
                         raw_bytes: bytes,
                         max_len: int) -> Optional[Gadget]:
        """验证并创建 Gadget 对象"""
        if not insns or len(insns) > max_len:
            return None

        # 最后一条指令必须是 RET
        last_insn = insns[-1]
        if last_insn.mnemonic not in ('ret', 'retf'):
            return None

        # 检查是否包含无效指令
        registers = []
        for i, insn in enumerate(insns[:-1]):  # 除了最后的 RET
            mnemonic = insn.mnemonic.lower()

            # 检查无效指令
            if mnemonic in self.INVALID_MNEMONICS:
                # 但 jmp reg 可能是有效的
                if mnemonic == 'jmp' and insn.op_str.lower() in self.VALID_JMP_REGS:
                    pass  # 允许 jmp esp 等
                else:
                    return None

            # 收集寄存器
            if insn.op_str:
                for reg in self.VALID_JMP_REGS:
                    if reg in insn.op_str.lower():
                        registers.append(reg)

        # 确定 gadget 类型
        gadget_type = self._classify_gadget(insns)

        # 构建指令字符串
        instructions = ' ; '.join([f"{insn.mnemonic} {insn.op_str}".strip() for insn in insns])

        return Gadget(
            address=insns[0].address,
            instructions=instructions,
            raw_bytes=raw_bytes,
            gadget_type=gadget_type,
            registers=list(set(registers))
        )

    def _classify_gadget(self, insns: list) -> str:
        """分类 gadget 类型"""
        if len(insns) == 1:
            return 'ret'

        first = insns[0].mnemonic.lower()

        # POP-RET 模式
        pop_count = sum(1 for i in insns[:-1] if i.mnemonic.lower() == 'pop')
        if pop_count > 0:
            if pop_count == len(insns) - 1:
                return f'pop{pop_count}-ret'
            return 'pop-mixed-ret'

        # MOV-RET 模式
        if first == 'mov':
            return 'mov-ret'

        # XCHG-RET 模式
        if first == 'xchg':
            return 'xchg-ret'

        # ADD/SUB-RET 模式
        if first in ('add', 'sub'):
            return f'{first}-ret'

        # JMP REG 模式
        if first == 'jmp':
            return 'jmp-reg'

        return 'other'

    def _filter_bad_chars(self, gadgets: List[Gadget], bad_chars: List[int]) -> List[Gadget]:
        """过滤包含坏字符的 gadget"""
        bad_set = set(bad_chars)
        return [g for g in gadgets if not any(b in bad_set for b in g.raw_bytes)]

    def find_by_type(self,
                     binary_path: str,
                     gadget_type: str) -> List[Gadget]:
        """
        按类型搜索 gadgets

        Args:
            binary_path: 二进制文件路径
            gadget_type: 类型 ('pop-ret', 'mov-ret', 'xchg-ret', 'jmp-reg', etc.)

        Returns:
            匹配的 Gadget 列表
        """
        all_gadgets = self.find_gadgets(binary_path)
        return [g for g in all_gadgets if gadget_type in g.gadget_type]

    def find_pop_reg(self,
                     binary_path: str,
                     register: str) -> Optional[Gadget]:
        """
        查找 POP <reg> ; RET 序列

        Args:
            binary_path: 二进制文件路径
            register: 目标寄存器 (e.g., 'eax', 'rax', 'rcx')

        Returns:
            找到的 Gadget 或 None
        """
        all_gadgets = self.find_gadgets(binary_path)
        reg_lower = register.lower()

        for g in all_gadgets:
            if 'pop' in g.gadget_type:
                # 检查是否是简单的 pop reg ; ret
                parts = g.instructions.lower().split(';')
                if len(parts) >= 2:
                    pop_part = parts[0].strip()
                    if pop_part == f'pop {reg_lower}' and 'ret' in parts[-1]:
                        return g

        return None

    def find_jmp_reg(self,
                     binary_path: str,
                     register: str) -> Optional[Gadget]:
        """
        查找 JMP <reg> 序列

        Args:
            binary_path: 二进制文件路径
            register: 目标寄存器 (e.g., 'esp', 'rsp')

        Returns:
            找到的 Gadget 或 None
        """
        all_gadgets = self.find_gadgets(binary_path)
        reg_lower = register.lower()

        for g in all_gadgets:
            if g.gadget_type == 'jmp-reg':
                if reg_lower in g.instructions.lower():
                    return g

        # 也搜索 call reg
        for g in all_gadgets:
            if f'call {reg_lower}' in g.instructions.lower():
                return g

        return None

    def find_stack_pivot(self, binary_path: str) -> List[Gadget]:
        """
        查找栈转移 gadgets

        用于将栈指针移动到攻击者控制的位置。

        Returns:
            栈转移 Gadget 列表
        """
        all_gadgets = self.find_gadgets(binary_path)
        pivots = []

        for g in all_gadgets:
            instr = g.instructions.lower()

            # xchg eax, esp 或类似
            if 'xchg' in instr and ('esp' in instr or 'rsp' in instr):
                pivots.append(g)

            # mov esp, ... 或 mov rsp, ...
            if 'mov esp,' in instr or 'mov rsp,' in instr:
                pivots.append(g)

            # add esp, large_value 或 sub esp, negative
            if ('add esp' in instr or 'add rsp' in instr or
                'sub esp' in instr or 'sub rsp' in instr):
                pivots.append(g)

        return pivots

    def find_write_gadgets(self, binary_path: str) -> List[Gadget]:
        """
        查找内存写入 gadgets

        用于写入任意地址。

        Returns:
            写入 Gadget 列表
        """
        all_gadgets = self.find_gadgets(binary_path)
        writers = []

        for g in all_gadgets:
            instr = g.instructions.lower()

            # mov [reg], reg 模式
            if 'mov [' in instr or 'mov dword [' in instr or 'mov qword [' in instr:
                writers.append(g)

        return writers

    def print_gadgets(self,
                      gadgets: List[Gadget],
                      limit: int = 50) -> None:
        """打印 gadgets 列表"""
        for i, g in enumerate(gadgets[:limit]):
            print(f"0x{g.address:08x}: {g.instructions} [{g.gadget_type}]")

        if len(gadgets) > limit:
            print(f"... and {len(gadgets) - limit} more")

    def export_to_python(self,
                         gadgets: List[Gadget],
                         var_name: str = 'gadgets') -> str:
        """导出为 Python 代码"""
        lines = [f"{var_name} = {{"]
        for g in gadgets:
            lines.append(f"    '{g.instructions}': 0x{g.address:x},")
        lines.append("}")
        return '\n'.join(lines)
