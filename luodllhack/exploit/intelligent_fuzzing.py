"""
intelligent_fuzzing.py - 智能模糊测试集成

将模糊测试与符号执行、污点分析相结合，创建智能模糊测试系统，
用于发现传统静态分析难以发现的漏洞。
"""

import os
import sys
import time
import random
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass, field
import logging
import tempfile
import threading
import queue

from ..core.types import VulnType
from ..analysis.taint import TaintPath
from ..analysis.neuro_symbolic import ZeroDayDiscoveryEngine
from ..symbolic.enhanced import AdvancedSymbolicExecutor

logger = logging.getLogger(__name__)

try:
    import psutil
    HAVE_PSUTIL = True
except ImportError:
    HAVE_PSUTIL = False
    psutil = None


@dataclass
class FuzzResult:
    """模糊测试结果"""
    seed_input: bytes
    mutated_input: bytes
    crash_detected: bool
    crash_details: Optional[str] = None
    execution_time: float = 0.0
    coverage_increased: bool = False
    new_paths: int = 0
    vuln_type: Optional[VulnType] = None
    confidence: float = 0.0


class MutationStrategy:
    """变异策略 - 生成智能变异载荷"""
    
    def __init__(self):
        self.strategies = [
            self._buffer_overflow_mutation,
            self._format_string_mutation,
            self._integer_overflow_mutation,
            self._heap_corruption_mutation,
            self._generic_mutation
        ]
        
    def generate_mutation(self, original_input: bytes, vuln_type: VulnType = None) -> bytes:
        """根据漏洞类型选择合适的变异策略"""
        if vuln_type == VulnType.BUFFER_OVERFLOW:
            return self._buffer_overflow_mutation(original_input)
        elif vuln_type == VulnType.FORMAT_STRING:
            return self._format_string_mutation(original_input)
        elif vuln_type == VulnType.INTEGER_OVERFLOW:
            return self._integer_overflow_mutation(original_input)
        elif vuln_type in [VulnType.HEAP_OVERFLOW, VulnType.DOUBLE_FREE, VulnType.USE_AFTER_FREE]:
            return self._heap_corruption_mutation(original_input)
        else:
            # 根据启发式选择策略
            strategy = random.choice(self.strategies)
            return strategy(original_input)
            
    def _buffer_overflow_mutation(self, input_data: bytes) -> bytes:
        """缓冲区溢出特定变异"""
        # 生成长输入以触发溢出
        size = random.randint(500, 5000)
        padding = b'A' * (size - len(input_data))
        return input_data + padding
        
    def _format_string_mutation(self, input_data: bytes) -> bytes:
        """格式化字符串变异"""
        # 插入格式化字符串载荷
        fmt_strings = [b'%n', b'%x', b'%s', b'%p', b'%d', b'%i', b'%o', b'%u']
        positions = [random.randint(0, len(input_data)) for _ in range(3)]
        
        result = bytearray(input_data)
        for pos in sorted(positions, reverse=True):
            fmt = random.choice(fmt_strings)
            result[pos:pos] = fmt
            
        return bytes(result)
        
    def _integer_overflow_mutation(self, input_data: bytes) -> bytes:
        """整数溢出变异"""
        # 插入大数值
        overflow_values = [
            b'\xFF\xFF\xFF\xFF',  # 0xFFFFFFFF
            b'\x00\x00\x00\x80',  # 0x80000000
            b'\xFF\xFF\xFF\x7F',  # 0x7FFFFFFF
        ]
        
        # 随机替换输入中的数字
        result = bytearray(input_data)
        for value in overflow_values:
            if len(result) > len(value):
                pos = random.randint(0, len(result) - len(value))
                result[pos:pos+len(value)] = value
                
        return bytes(result)
        
    def _heap_corruption_mutation(self, input_data: bytes) -> bytes:
        """堆损坏变异"""
        # 包含堆管理相关的载荷
        heap_payloads = [
            b'\x00' * 16,  # 空指针
            b'\xFF' * 16,  # 大地址
            b'\x41' * 32 + b'\x00' * 8,  # 经典模式
        ]
        
        base = input_data
        for _ in range(3):
            payload = random.choice(heap_payloads)
            pos = random.randint(0, len(base))
            base = base[:pos] + payload + base[pos:]
            
        return base
        
    def _generic_mutation(self, input_data: bytes) -> bytes:
        """通用变异策略"""
        mutations = [
            lambda x: x + b'A' * random.randint(1, 100),  # 添加随机数据
            lambda x: x[:len(x)//2] + b'B' * 50 + x[len(x)//2:],  # 插入中间
            lambda x: x * random.randint(1, 3),  # 重复
            lambda x: x + b'\x00' * random.randint(1, 50),  # 添加零字节
        ]
        
        mutation = random.choice(mutations)
        return mutation(input_data)


class ProcessMonitor:
    """进程监控器 - 监控目标进程的执行"""
    
    def __init__(self):
        self.monitoring = False
        self.crash_detected = False
        self.crash_info = ""
        
    def start_monitoring(self, process):
        """开始监控进程"""
        self.monitoring = True
        self.crash_detected = False
        self.crash_info = ""
        
        monitor_thread = threading.Thread(target=self._monitor_loop, args=(process,))
        monitor_thread.daemon = True
        monitor_thread.start()
        
    def stop_monitoring(self):
        """停止监控"""
        self.monitoring = False
        
    def _monitor_loop(self, process):
        """监控循环"""
        while self.monitoring and process.poll() is None:
            try:
                # 检查进程状态
                if psutil:
                    try:
                        proc = psutil.Process(process.pid)
                        # 检查内存使用是否异常
                        memory_info = proc.memory_info()
                        if memory_info.rss > 1024 * 1024 * 1024:  # 1GB
                            self.crash_detected = True
                            self.crash_info = "Memory consumption too high"
                            break
                    except psutil.NoSuchProcess:
                        self.crash_detected = True
                        self.crash_info = "Process terminated unexpectedly"
                        break
                else:
                    # 没有psutil时，使用简单的检查
                    if process.poll() is not None:
                        # 进程已退出
                        return_time = process.returncode
                        if return_time != 0 and return_time != None:
                            self.crash_detected = True
                            self.crash_info = f"Process exited with code {return_time}"
                        break
                        
                time.sleep(0.01)  # 10ms
            except Exception as e:
                logger.debug(f"Monitoring error: {e}")
                break


class IntelligentFuzzer:
    """
    智能模糊测试器 - 结合多种技术进行智能模糊测试
    
    核心改进：
    1. 基于漏洞分析结果的智能变异
    2. 实时监控和崩溃检测
    3. 覆盖率引导的模糊测试
    4. 与符号执行结果结合
    """
    
    def __init__(self, dll_path: Path, export_name: str, config=None):
        self.dll_path = dll_path
        self.export_name = export_name
        self.config = config
        self.mutation_strategy = MutationStrategy()
        self.process_monitor = ProcessMonitor()
        
        # 用于存储测试用例和结果
        self.test_cases: List[bytes] = []
        self.results: List[FuzzResult] = []
        self.crash_inputs: List[bytes] = []
        
        # 模糊测试统计
        self.stats = {
            'total_tests': 0,
            'crashes_found': 0,
            'new_paths': 0,
            'execution_time': 0.0,
            'coverage_increase': 0
        }
        
    def generate_initial_test_cases(self, taint_paths: List[TaintPath], 
                                  num_cases: int = 100) -> List[bytes]:
        """基于污点路径生成初始测试用例"""
        test_cases = []
        
        for _ in range(num_cases):
            # 随机选择一个污点路径作为基础
            if taint_paths:
                base_path = random.choice(taint_paths)
                base_input = self._generate_base_input(base_path)
            else:
                base_input = b'A' * 100  # 默认输入
                
            # 应用智能变异
            mutated_input = self.mutation_strategy.generate_mutation(
                base_input, 
                base_path.sink.vuln_type if taint_paths else None
            )
            
            test_cases.append(mutated_input)
            
        return test_cases
        
    def _generate_base_input(self, taint_path: TaintPath) -> bytes:
        """基于污点路径生成基础输入"""
        # 根据污点路径的特征生成输入
        vuln_type = taint_path.sink.vuln_type
        
        if vuln_type == VulnType.BUFFER_OVERFLOW:
            return b'A' * 256
        elif vuln_type == VulnType.FORMAT_STRING:
            return b'%x.%n.%s.%p'
        elif vuln_type == VulnType.INTEGER_OVERFLOW:
            return b'\xFF\xFF\xFF\xFF'  # 0xFFFFFFFF
        elif vuln_type == VulnType.COMMAND_INJECTION:
            return b';calc.exe;'  # 简化示例
        else:
            return b'BASE_INPUT'
            
    def fuzz_with_input(self, input_data: bytes, timeout: int = 5) -> FuzzResult:
        """使用单个输入进行模糊测试"""
        start_time = time.time()
        
        # 创建临时输入文件
        with tempfile.NamedTemporaryFile(delete=False) as temp_input:
            temp_input.write(input_data)
            temp_input_path = temp_input.name
            
        try:
            # 创建测试程序（需要实现一个能加载DLL并调用导出函数的程序）
            test_exe_path = self._create_test_program()
            
            # 执行测试
            result = self._execute_test(test_exe_path, temp_input_path, timeout)
            
            fuzz_result = FuzzResult(
                seed_input=input_data,
                mutated_input=input_data,
                crash_detected=result['crashed'],
                crash_details=result['crash_info'],
                execution_time=time.time() - start_time,
                coverage_increased=False,  # 覆盖率需要额外实现
                new_paths=0,
                vuln_type=None,
                confidence=0.5  # 默认置信度
            )
            
            return fuzz_result
            
        finally:
            # 清理临时文件
            try:
                os.unlink(temp_input_path)
            except:
                pass
                
    def _create_test_program(self) -> Path:
        """创建测试程序 - 加载DLL并调用导出函数"""
        # 创建一个简单的C程序来加载DLL并调用导出函数
        test_code = f'''
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

typedef int (*TargetFunc)(void*, int);

int main(int argc, char* argv[]) {{
    if (argc != 2) {{
        printf("Usage: %s <input_file>\\n", argv[0]);
        return 1;
    }}
    
    // 读取输入文件
    FILE* f = fopen(argv[1], "rb");
    if (!f) {{
        printf("Cannot open input file\\n");
        return 1;
    }}
    
    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* buffer = malloc(len);
    if (!buffer) {{
        printf("Cannot allocate memory\\n");
        fclose(f);
        return 1;
    }}
    
    fread(buffer, 1, len, f);
    fclose(f);
    
    // 加载DLL
    HMODULE hDll = LoadLibraryA("{self.dll_path.name}");
    if (!hDll) {{
        printf("Cannot load DLL\\n");
        free(buffer);
        return 1;
    }}
    
    // 获取函数地址
    TargetFunc func = (TargetFunc)GetProcAddress(hDll, "{self.export_name}");
    if (!func) {{
        printf("Cannot get function address\\n");
        FreeLibrary(hDll);
        free(buffer);
        return 1;
    }}
    
    // 调用函数
    int result = func(buffer, (int)len);
    
    // 清理
    FreeLibrary(hDll);
    free(buffer);
    
    return result;
}}
'''
        
        # 将测试代码写入临时文件
        with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as temp_c:
            temp_c.write(test_code)
            temp_c_path = temp_c.name
            
        # 编译测试程序
        exe_path = temp_c_path.replace('.c', '.exe')
        
        try:
            # 尝试使用MSVC编译
            result = subprocess.run([
                'cl', '/nologo', '/O2', '/Fe:' + exe_path, temp_c_path
            ], capture_output=True, timeout=30)
            
            if result.returncode != 0:
                # 如果MSVC不可用，创建一个模拟程序
                # 这里我们创建一个简单的Python模拟程序
                self._create_python_test_program(exe_path)
                
        except (subprocess.TimeoutExpired, FileNotFoundError):
            # 如果编译失败，创建Python模拟程序
            self._create_python_test_program(exe_path)
            
        return Path(exe_path)
        
    def _create_python_test_program(self, exe_path: str):
        """创建Python测试程序作为备选方案"""
        # 创建一个简单的Python脚本来模拟测试
        import ctypes
        
        # 我们创建一个Python脚本而不是可执行文件
        # 但为了保持接口一致性，这里创建一个批处理文件
        bat_content = f'''@echo off
python -c "
import ctypes
import sys

if len(sys.argv) != 2:
    print('Usage: %%0 <input_file>')
    exit(1)

# 读取输入
with open(sys.argv[1], 'rb') as f:
    input_data = f.read()

try:
    # 加载DLL
    dll = ctypes.CDLL('{self.dll_path}')
    func = getattr(dll, '{self.export_name}')
    
    # 调用函数
    result = func(input_data, len(input_data))
    exit(result)
except Exception as e:
    print(f'Error: {{e}}')
    exit(-1)
" %*
'''
        
        bat_path = exe_path.replace('.exe', '.bat')
        with open(bat_path, 'w') as f:
            f.write(bat_content)
        
    def _execute_test(self, test_exe: Path, input_file: str, timeout: int) -> Dict[str, Any]:
        """执行单次测试并监控结果"""
        try:
            # 启动测试进程
            start_time = time.time()
            
            cmd = [str(test_exe), input_file]
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                creationflags=subprocess.CREATE_NEW_CONSOLE if os.name == 'nt' else 0
            )
            
            # 开始监控
            self.process_monitor.start_monitoring(process)
            
            try:
                stdout, stderr = process.communicate(timeout=timeout)
                execution_time = time.time() - start_time
                
                # 检查返回码
                crashed = process.returncode != 0 and process.returncode is not None
                
                result = {
                    'crashed': crashed,
                    'crash_info': stderr.decode() if stderr else str(stdout),
                    'execution_time': execution_time,
                    'return_code': process.returncode
                }
                
            except subprocess.TimeoutExpired:
                # 超时 - 可能是无限循环或挂起
                process.kill()
                result = {
                    'crashed': True,
                    'crash_info': 'Process timed out',
                    'execution_time': timeout,
                    'return_code': None
                }
                
        except Exception as e:
            result = {
                'crashed': True,
                'crash_info': f'Execution error: {str(e)}',
                'execution_time': 0,
                'return_code': -1
            }
            
        return result
        
    def intelligent_fuzzing(self, taint_paths: List[TaintPath], 
                          iterations: int = 1000, timeout: int = 5) -> List[FuzzResult]:
        """
        智能模糊测试 - 结合污点分析结果
        
        Args:
            taint_paths: 污点路径列表
            iterations: 测试迭代次数
            timeout: 单次测试超时时间
            
        Returns:
            测试结果列表
        """
        logger.info(f"Starting intelligent fuzzing with {iterations} iterations")
        
        # 生成初始测试用例
        test_cases = self.generate_initial_test_cases(taint_paths, min(100, iterations))
        
        results = []
        
        start_time = time.time()
        
        for i in range(iterations):
            # 选择测试用例
            if i < len(test_cases):
                input_data = test_cases[i]
            else:
                # 基于已有结果生成新测试用例
                input_data = self._generate_adaptive_input(results)
                
            # 执行测试
            try:
                result = self.fuzz_with_input(input_data, timeout)
                results.append(result)
                
                # 更新统计
                self.stats['total_tests'] += 1
                if result.crash_detected:
                    self.stats['crashes_found'] += 1
                    self.crash_inputs.append(input_data)
                    logger.info(f"Crash found at iteration {i}: {result.crash_details}")
                    
                # 记录结果
                self.results.append(result)
                
            except Exception as e:
                logger.error(f"Error during fuzzing iteration {i}: {e}")
                
            # 更新进度
            if (i + 1) % 100 == 0:
                logger.info(f"Progress: {i + 1}/{iterations} tests completed")
                
        self.stats['execution_time'] = time.time() - start_time
        logger.info(f"Fuzzing completed. Found {self.stats['crashes_found']} crashes")
        
        return results
        
    def _generate_adaptive_input(self, previous_results: List[FuzzResult]) -> bytes:
        """基于先前结果生成自适应输入"""
        if not previous_results:
            return b'ADAPTIVE_INPUT'
            
        # 分析先前的崩溃模式
        crash_inputs = [r.mutated_input for r in previous_results if r.crash_detected]
        
        if crash_inputs:
            # 基于崩溃输入生成变异
            base_input = random.choice(crash_inputs)
            return self.mutation_strategy._generic_mutation(base_input)
        else:
            # 随机生成
            return b'A' * random.randint(100, 1000)
            
    def analyze_results(self) -> Dict[str, Any]:
        """分析模糊测试结果"""
        analysis = {
            'total_tests': self.stats['total_tests'],
            'crashes_found': self.stats['crashes_found'],
            'crash_rate': self.stats['crashes_found'] / max(1, self.stats['total_tests']),
            'execution_time': self.stats['execution_time'],
            'avg_test_time': self.stats['execution_time'] / max(1, self.stats['total_tests']),
            'unique_crashes': len(set(self.crash_inputs))
        }
        
        # 分析崩溃模式
        if self.crash_inputs:
            analysis['most_common_crash_pattern'] = self._analyze_crash_patterns()
            
        return analysis
        
    def _analyze_crash_patterns(self) -> Dict[str, Any]:
        """分析崩溃模式"""
        if not self.crash_inputs:
            return {}
            
        # 简单分析：找出最常见的输入模式
        patterns = {}
        for crash_input in self.crash_inputs:
            # 分析输入的结构特征
            size = len(crash_input)
            null_bytes = crash_input.count(b'\x00')
            printable_chars = len([b for b in crash_input if 32 <= b <= 126])
            
            pattern = f"size_{size}_nulls_{null_bytes}_printable_{printable_chars}"
            patterns[pattern] = patterns.get(pattern, 0) + 1
            
        # 返回最常见的模式
        if patterns:
            most_common = max(patterns.items(), key=lambda x: x[1])
            return {'pattern': most_common[0], 'count': most_common[1]}
            
        return {}


class HybridAnalysisEngine:
    """
    混合分析引擎 - 结合符号执行、污点分析和模糊测试

    这是0day发现能力的核心改进：多技术融合分析

    支持两种模糊测试模式:
    1. 内部模糊测试 (IntelligentFuzzer) - 默认启用
    2. 外部模糊测试 (ExternalFuzzerIntegration) - 可选，支持 WinAFL/AFL/LibFuzzer
    """

    def __init__(self, binary_path: Path, config=None):
        self.binary_path = binary_path
        self.config = config

        # 初始化各组件
        self.neuro_symbolic_engine = ZeroDayDiscoveryEngine(binary_path, config)
        self.advanced_symbolic = AdvancedSymbolicExecutor(binary_path, config)
        self.intelligent_fuzzer = None  # 延迟初始化 (内部模糊测试)
        self.external_fuzzer = None     # 延迟初始化 (外部模糊测试)

        # 统计信息
        self.stats = {
            'explored_paths': 0,
            'solved_paths': 0,
            'pruned_paths': 0,
            'constraint_failures': 0,
            'fuzz_crashes': 0,
            'external_fuzz_crashes': 0
        }
        
    def hybrid_analysis(self, taint_paths: List[TaintPath]) -> List[TaintPath]:
        """
        混合分析 - 多技术联合分析

        步骤：
        1. 神经符号分析识别潜在0day
        2. 符号执行验证可利用性
        3. 内部模糊测试确认漏洞存在
        4. (可选) 外部模糊测试深度验证
        """
        logger.info("Starting hybrid analysis...")

        # 步骤1: 神经符号分析 - 发现潜在0day
        potential_0days = self.neuro_symbolic_engine.discover_potential_0days(taint_paths)
        logger.info(f"Neuro-symbolic analysis found {len(potential_0days)} potential 0days")
        self.stats['explored_paths'] = len(potential_0days)

        # 步骤2: 对每个潜在0day进行符号执行验证
        confirmed_paths = []
        for path in potential_0days:
            try:
                # 使用增强符号执行验证路径
                solution = self.advanced_symbolic.solve_vulnerability_path(path)
                if solution:
                    # 增加置信度
                    path.confidence = min(0.95, path.confidence + 0.2)
                    confirmed_paths.append(path)
                    self.stats['solved_paths'] += 1
                    logger.info(f"Symbolic execution confirmed path to 0x{path.sink.addr:x}")
                else:
                    self.stats['constraint_failures'] += 1
            except Exception as e:
                self.stats['constraint_failures'] += 1
                logger.debug(f"Symbolic execution failed for path: {e}")

        # 检查配置中是否启用模糊测试
        fuzz_enable = True
        if self.config and hasattr(self.config, 'fuzz_enable'):
            fuzz_enable = self.config.fuzz_enable

        # 步骤3: 对确认的路径进行内部模糊测试验证
        if fuzz_enable and confirmed_paths and len(confirmed_paths) > 0:
            # 初始化模糊测试器（使用第一个路径的导出函数）
            first_path = confirmed_paths[0]
            export_name = first_path.func_name or "unknown_export"
            self.intelligent_fuzzer = IntelligentFuzzer(
                self.binary_path, export_name, self.config
            )

            # 获取迭代次数配置
            fuzz_iterations = 500
            if self.config and hasattr(self.config, 'fuzz_iterations'):
                fuzz_iterations = self.config.fuzz_iterations

            # 对确认路径进行模糊测试
            fuzz_results = self.intelligent_fuzzer.intelligent_fuzzing(
                confirmed_paths,
                iterations=min(500, fuzz_iterations)
            )

            # 分析模糊测试结果
            fuzz_analysis = self.intelligent_fuzzer.analyze_results()
            self.stats['fuzz_crashes'] = fuzz_analysis.get('crashes_found', 0)
            logger.info(f"Internal fuzzing analysis: {fuzz_analysis}")

        # 步骤4: (可选) 外部模糊测试深度验证
        external_fuzz_enable = False
        if self.config and hasattr(self.config, 'fuzz_external_enable'):
            external_fuzz_enable = self.config.fuzz_external_enable

        if external_fuzz_enable and confirmed_paths:
            external_results = self._run_external_fuzzing(confirmed_paths)
            if external_results:
                self.stats['external_fuzz_crashes'] = external_results.get('crashes', 0)
                logger.info(f"External fuzzing results: {external_results}")

        # 更新统计
        try:
            neuro_stats = self.advanced_symbolic.get_stats()
            logger.info(f"Analysis completed. Stats: {neuro_stats}")
        except Exception:
            pass

        return confirmed_paths

    def _run_external_fuzzing(self, confirmed_paths: List[TaintPath]) -> Optional[Dict[str, Any]]:
        """
        运行外部模糊测试 (WinAFL/AFL/LibFuzzer)

        Args:
            confirmed_paths: 已确认的漏洞路径列表

        Returns:
            模糊测试结果字典
        """
        if not confirmed_paths:
            return None

        # 获取配置
        fuzz_type = "winafl"
        fuzz_timeout = 60
        fuzz_output_dir = None
        fuzz_seeds_dir = None
        fuzz_generate_harness = True

        if self.config:
            fuzz_type = getattr(self.config, 'fuzz_external_type', 'winafl')
            fuzz_timeout = getattr(self.config, 'fuzz_external_timeout', 60)
            fuzz_output_dir = getattr(self.config, 'fuzz_output_dir', None)
            fuzz_seeds_dir = getattr(self.config, 'fuzz_seeds_dir', None)
            fuzz_generate_harness = getattr(self.config, 'fuzz_generate_harness', True)

        # 初始化外部Fuzzer集成
        try:
            self.external_fuzzer = ExternalFuzzerIntegration(self.binary_path, self.config)
        except Exception as e:
            logger.error(f"Failed to initialize external fuzzer: {e}")
            return None

        # 检测可用的Fuzzer
        available_fuzzers = [k for k, v in self.external_fuzzer.fuzzer_paths.items() if v]
        if not available_fuzzers:
            logger.warning("No external fuzzers detected. Set WINAFL_PATH or AFL_PATH environment variable.")
            return {'status': 'no_fuzzer_available', 'crashes': 0}

        logger.info(f"Available external fuzzers: {available_fuzzers}")

        # 获取目标函数
        first_path = confirmed_paths[0]
        target_func = first_path.func_name or "target_function"

        # 设置输出目录
        if fuzz_output_dir is None:
            fuzz_output_dir = Path(tempfile.mkdtemp(prefix="luodllhack_fuzz_"))
        else:
            fuzz_output_dir = Path(fuzz_output_dir)
        fuzz_output_dir.mkdir(parents=True, exist_ok=True)

        # 生成种子文件
        if fuzz_seeds_dir is None:
            fuzz_seeds_dir = fuzz_output_dir / "seeds"
        else:
            fuzz_seeds_dir = Path(fuzz_seeds_dir)

        seed_count = self.external_fuzzer.prepare_seeds_from_analysis(
            confirmed_paths, fuzz_seeds_dir
        )
        logger.info(f"Generated {seed_count} seed files for external fuzzing")

        # 生成Harness代码
        harness_code = None
        harness_path = None
        if fuzz_generate_harness:
            if fuzz_type == 'winafl':
                harness_code = self.external_fuzzer.create_winafl_harness(target_func)
            elif fuzz_type == 'libfuzzer':
                harness_code = self.external_fuzzer.create_libfuzzer_harness(target_func)
            else:
                harness_code = self.external_fuzzer.create_winafl_harness(target_func)

            # 保存Harness代码
            harness_path = fuzz_output_dir / f"harness_{target_func}.c"
            with open(harness_path, 'w') as f:
                f.write(harness_code)
            logger.info(f"Generated fuzzing harness: {harness_path}")

            # 注意: 实际使用时需要编译harness
            # 这里只生成代码，编译需要用户手动执行或配置编译工具链
            logger.warning(f"Harness code generated but not compiled. "
                          f"Compile with: cl /nologo /O2 /Fe:harness.exe {harness_path}")

        # 生成Fuzzer命令 (供用户参考)
        result = {
            'status': 'prepared',
            'fuzzer_type': fuzz_type,
            'target_function': target_func,
            'seeds_dir': str(fuzz_seeds_dir),
            'output_dir': str(fuzz_output_dir),
            'seed_count': seed_count,
            'harness_path': str(harness_path) if harness_path else None,
            'crashes': 0
        }

        # 如果已经有编译好的harness，尝试运行fuzzer
        compiled_harness = fuzz_output_dir / "harness.exe"
        if compiled_harness.exists():
            try:
                logger.info(f"Running {fuzz_type} fuzzer for {fuzz_timeout} minutes...")
                fuzz_result = self.external_fuzzer.run_fuzzer(
                    fuzz_type,
                    compiled_harness,
                    fuzz_seeds_dir,
                    fuzz_output_dir / "fuzz_output",
                    timeout_minutes=fuzz_timeout
                )
                result.update(fuzz_result)
                result['status'] = 'completed'
            except Exception as e:
                logger.error(f"External fuzzer execution failed: {e}")
                result['status'] = f'error: {str(e)}'
        else:
            logger.info(f"Harness not compiled. To run fuzzing, compile the harness first.")
            result['status'] = 'harness_not_compiled'

            # 打印fuzzer命令供用户参考
            if fuzz_type in ('winafl', 'afl') and self.external_fuzzer.fuzzer_paths.get(fuzz_type):
                try:
                    cmd = self.external_fuzzer.generate_winafl_command(
                        compiled_harness, fuzz_seeds_dir, fuzz_output_dir / "fuzz_output"
                    ) if fuzz_type == 'winafl' else self.external_fuzzer.generate_afl_command(
                        compiled_harness, fuzz_seeds_dir, fuzz_output_dir / "fuzz_output"
                    )
                    result['fuzzer_command'] = ' '.join(cmd)
                    logger.info(f"Fuzzer command: {result['fuzzer_command']}")
                except Exception:
                    pass

        return result


# 工具函数
def get_hybrid_analysis_engine(binary_path: Path, config=None):
    """获取混合分析引擎"""
    return HybridAnalysisEngine(binary_path, config)

class ExternalFuzzerIntegration:
    """
    外部Fuzzer集成 - 对接WinAFL、LibFuzzer等成熟工具

    支持的Fuzzer:
    - WinAFL: Windows平台的AFL移植版，使用DynamoRIO进行覆盖率收集
    - LibFuzzer: LLVM的覆盖率引导模糊测试库
    - AFL/AFL++: 经典的覆盖率引导模糊测试工具
    """

    def __init__(self, binary_path: Path, config=None):
        self.binary_path = binary_path
        self.config = config
        self.fuzzer_paths = self._detect_fuzzers()

    def _detect_fuzzers(self) -> Dict[str, Optional[Path]]:
        """检测系统中安装的Fuzzer"""
        fuzzers = {'winafl': None, 'drrun': None, 'afl-fuzz': None}

        search_paths = [
            os.environ.get('WINAFL_PATH', ''),
            os.environ.get('DYNAMORIO_PATH', ''),
            os.environ.get('AFL_PATH', ''),
            'C:/tools/winafl',
            'C:/tools/DynamoRIO',
            '/usr/local/bin',
        ]

        for search_path in search_paths:
            if not search_path:
                continue
            path = Path(search_path)
            if not path.exists():
                continue

            winafl_exe = path / 'build64/bin/Release/afl-fuzz.exe'
            if winafl_exe.exists() and not fuzzers['winafl']:
                fuzzers['winafl'] = winafl_exe

            drrun = path / 'bin64/drrun.exe'
            if drrun.exists() and not fuzzers['drrun']:
                fuzzers['drrun'] = drrun

            afl_fuzz = path / 'afl-fuzz'
            if afl_fuzz.exists() and not fuzzers['afl-fuzz']:
                fuzzers['afl-fuzz'] = afl_fuzz

        logger.info(f"Detected fuzzers: {[k for k, v in fuzzers.items() if v]}")
        return fuzzers

    def create_winafl_harness(self, target_func: str) -> str:
        """创建WinAFL测试harness代码"""
        dll_name = self.binary_path.name
        return f"""// WinAFL Harness for {dll_name}
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

typedef int (*TargetFunc)(const char*, int);
TargetFunc g_target_func = NULL;
HMODULE g_dll = NULL;

__declspec(noinline) void target_init(void) {{
    g_dll = LoadLibraryA("{dll_name}");
    if (g_dll) g_target_func = (TargetFunc)GetProcAddress(g_dll, "{target_func}");
}}

__declspec(noinline) int fuzz_target(const char* data, int len) {{
    if (!g_target_func) target_init();
    if (!g_target_func) return -1;
    return g_target_func(data, len);
}}

int main(int argc, char* argv[]) {{
    if (argc < 2) return 1;
    FILE* f = fopen(argv[1], "rb");
    if (!f) return 1;
    fseek(f, 0, SEEK_END);
    int len = ftell(f);
    fseek(f, 0, SEEK_SET);
    char* buf = malloc(len);
    fread(buf, 1, len, f);
    fclose(f);
    int r = fuzz_target(buf, len);
    free(buf);
    return r;
}}
"""

    def create_libfuzzer_harness(self, target_func: str) -> str:
        """创建LibFuzzer测试harness代码"""
        dll_name = self.binary_path.name
        return f"""// LibFuzzer Harness
#include <cstdint>
#include <cstdlib>
#include <cstring>
#ifdef _WIN32
#include <windows.h>
typedef int (*TargetFunc)(const char*, int);
static TargetFunc g_target = nullptr;
static HMODULE g_dll = nullptr;
void init_target() {{
    if (!g_dll) {{
        g_dll = LoadLibraryA("{dll_name}");
        if (g_dll) g_target = (TargetFunc)GetProcAddress(g_dll, "{target_func}");
    }}
}}
#endif
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {{
    if (!g_target) {{ init_target(); if (!g_target) return 0; }}
    char* buf = (char*)malloc(size + 1);
    if (!buf) return 0;
    memcpy(buf, data, size);
    buf[size] = 0;
    g_target(buf, (int)size);
    free(buf);
    return 0;
}}
"""

    def generate_winafl_command(self, harness_exe: Path, input_dir: Path,
                                output_dir: Path) -> List[str]:
        """生成WinAFL命令行"""
        if not self.fuzzer_paths['winafl']:
            raise RuntimeError("WinAFL not found. Set WINAFL_PATH env var.")
        if not self.fuzzer_paths['drrun']:
            raise RuntimeError("DynamoRIO not found. Set DYNAMORIO_PATH env var.")

        return [
            str(self.fuzzer_paths['winafl']),
            '-i', str(input_dir), '-o', str(output_dir), '-t', '5000',
            '-D', str(self.fuzzer_paths['drrun'].parent.parent),
            '--', '-coverage_module', self.binary_path.name,
            '-target_module', harness_exe.name, '-target_method', 'fuzz_target',
            '-nargs', '2', '--', str(harness_exe), '@@'
        ]

    def generate_afl_command(self, harness_exe: Path, input_dir: Path,
                            output_dir: Path) -> List[str]:
        """生成AFL命令行"""
        if not self.fuzzer_paths['afl-fuzz']:
            raise RuntimeError("AFL not found. Set AFL_PATH env var.")
        return [
            str(self.fuzzer_paths['afl-fuzz']),
            '-i', str(input_dir), '-o', str(output_dir),
            '-t', '5000', '-m', 'none', '--', str(harness_exe), '@@'
        ]

    def prepare_seeds_from_analysis(self, taint_paths: List[TaintPath],
                                   output_dir: Path) -> int:
        """基于污点分析结果生成种子文件"""
        output_dir.mkdir(parents=True, exist_ok=True)
        mutation = MutationStrategy()
        count = 0

        for i, path in enumerate(taint_paths):
            vuln_type = path.sink.vuln_type
            base_inputs = []

            if vuln_type == VulnType.BUFFER_OVERFLOW:
                base_inputs = [b'A' * 100, b'A' * 500, b'A' * 1000]
            elif vuln_type == VulnType.FORMAT_STRING:
                base_inputs = [b'%x.%x.%x', b'%n%n%n', b'%s%s%s']
            elif vuln_type == VulnType.INTEGER_OVERFLOW:
                base_inputs = [b'\xff' * 4, b'\x00\x00\x00\x80']
            else:
                base_inputs = [b'A' * 100, b'test_input']

            for j, base_input in enumerate(base_inputs):
                seed_path = output_dir / f'seed_{i}_{j}.bin'
                with open(seed_path, 'wb') as f:
                    f.write(base_input)
                count += 1

                for k in range(2):
                    mutated = mutation.generate_mutation(base_input, vuln_type)
                    mutated_path = output_dir / f'seed_{i}_{j}_m{k}.bin'
                    with open(mutated_path, 'wb') as f:
                        f.write(mutated)
                    count += 1

        logger.info(f"Generated {count} seed files in {output_dir}")
        return count

    def run_fuzzer(self, fuzzer_type: str, harness_exe: Path,
                   input_dir: Path, output_dir: Path,
                   timeout_minutes: int = 60) -> Dict[str, Any]:
        """运行指定的Fuzzer"""
        output_dir.mkdir(parents=True, exist_ok=True)

        if fuzzer_type == 'winafl':
            cmd = self.generate_winafl_command(harness_exe, input_dir, output_dir)
        elif fuzzer_type == 'afl':
            cmd = self.generate_afl_command(harness_exe, input_dir, output_dir)
        else:
            raise ValueError(f"Unsupported fuzzer: {fuzzer_type}")

        logger.info(f"Running {fuzzer_type}: {' '.join(cmd)}")

        result = {
            'fuzzer': fuzzer_type, 'crashes': 0, 'hangs': 0,
            'runtime_seconds': 0, 'status': 'unknown'
        }

        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            start_time = time.time()
            timeout_sec = timeout_minutes * 60

            while time.time() - start_time < timeout_sec:
                if process.poll() is not None:
                    break
                time.sleep(10)

                crashes_dir = output_dir / 'crashes'
                hangs_dir = output_dir / 'hangs'
                if crashes_dir.exists():
                    result['crashes'] = len(list(crashes_dir.iterdir()))
                if hangs_dir.exists():
                    result['hangs'] = len(list(hangs_dir.iterdir()))

            if process.poll() is None:
                process.terminate()
                process.wait(timeout=10)

            result['runtime_seconds'] = time.time() - start_time
            result['status'] = 'completed'
        except Exception as e:
            logger.error(f"Fuzzer error: {e}")
            result['status'] = f'error: {str(e)}'

        return result


def get_external_fuzzer_integration(binary_path: Path, config=None):
    """获取外部Fuzzer集成实例"""
    return ExternalFuzzerIntegration(binary_path, config)
