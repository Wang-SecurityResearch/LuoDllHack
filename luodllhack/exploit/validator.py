# -*- coding: utf-8 -*-
"""
luodllhack/exploit/validator.py - PoC 验证器

验证生成的 PoC 有效性:
- 静态验证 (代码检查)
- 动态验证 (沙箱执行)
- 崩溃分析
"""

from typing import Dict, List, Set, Optional, Tuple, Any
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum, auto
import subprocess
import tempfile
import os
import logging

logger = logging.getLogger(__name__)


class ValidationStatus(Enum):
    """验证状态"""
    SUCCESS = auto()        # 成功触发漏洞
    CRASH = auto()          # 导致崩溃
    NO_CRASH = auto()       # 未崩溃 (可能失败)
    TIMEOUT = auto()        # 超时
    ERROR = auto()          # 执行错误
    SKIPPED = auto()        # 跳过验证


class CrashType(Enum):
    """崩溃类型"""
    ACCESS_VIOLATION = auto()
    STACK_OVERFLOW = auto()
    HEAP_CORRUPTION = auto()
    CONTROL_FLOW = auto()
    UNKNOWN = auto()


@dataclass
class ValidationResult:
    """验证结果"""
    status: ValidationStatus
    poc_file: str
    crash_type: Optional[CrashType] = None
    crash_address: Optional[int] = None
    exception_code: Optional[int] = None
    stdout: str = ""
    stderr: str = ""
    execution_time: float = 0.0
    notes: List[str] = field(default_factory=list)

    # 误报检测相关字段
    is_false_positive: bool = False
    false_positive_reason: Optional[str] = None
    matched_arg_value: Optional[int] = None

    def to_dict(self) -> Dict:
        result = {
            'status': self.status.name,
            'poc_file': self.poc_file,
            'crash_type': self.crash_type.name if self.crash_type else None,
            'crash_address': f'0x{self.crash_address:x}' if self.crash_address else None,
            'exception_code': f'0x{self.exception_code:x}' if self.exception_code else None,
            'execution_time': self.execution_time,
            'notes': self.notes,
            'is_false_positive': self.is_false_positive,
            'false_positive_reason': self.false_positive_reason,
        }
        if self.matched_arg_value is not None:
            result['matched_arg_value'] = f'0x{self.matched_arg_value:x}'
        return result


class PoCValidator:
    """
    PoC 验证器

    验证生成的 PoC 是否能成功触发漏洞

    用法:
        validator = PoCValidator()

        # 静态验证
        result = validator.validate_static(poc_code)

        # 动态验证 (在沙箱中运行)
        result = validator.validate_dynamic(poc_file, timeout=30)
    """

    # Windows 异常代码
    EXCEPTION_CODES = {
        0xC0000005: ('ACCESS_VIOLATION', CrashType.ACCESS_VIOLATION),
        0xC00000FD: ('STACK_OVERFLOW', CrashType.STACK_OVERFLOW),
        0xC0000374: ('HEAP_CORRUPTION', CrashType.HEAP_CORRUPTION),
        0x80000003: ('BREAKPOINT', CrashType.UNKNOWN),
        0xC0000409: ('STACK_BUFFER_OVERRUN', CrashType.STACK_OVERFLOW),
    }

    def __init__(self, sandbox_enabled: bool = True):
        self.sandbox_enabled = sandbox_enabled
        self.validation_history: List[ValidationResult] = []

    def validate_static(self, poc_code: str) -> ValidationResult:
        """
        静态验证 PoC 代码

        Args:
            poc_code: PoC 源代码

        Returns:
            ValidationResult
        """
        notes = []

        # 检查基本语法
        try:
            compile(poc_code, '<poc>', 'exec')
            notes.append("Syntax check: PASS")
        except SyntaxError as e:
            return ValidationResult(
                status=ValidationStatus.ERROR,
                poc_file='<string>',
                notes=[f"Syntax error: {e}"]
            )

        # 检查危险操作
        dangerous_patterns = [
            ('os.system', "Uses os.system()"),
            ('subprocess.', "Uses subprocess"),
            ('ctypes.CDLL', "Loads DLL"),
            ('ctypes.WinDLL', "Loads Windows DLL"),
            ('eval(', "Uses eval()"),
            ('exec(', "Uses exec()"),
        ]

        for pattern, desc in dangerous_patterns:
            if pattern in poc_code:
                notes.append(f"Contains: {desc}")

        # 检查是否有 payload
        if 'payload' in poc_code.lower():
            notes.append("Contains payload definition")
        else:
            notes.append("WARNING: No payload found")

        # 检查是否有触发代码 (被注释)
        commented_trigger = any([
            '# func(' in poc_code,
            '# pFunc(' in poc_code,
            '# dll.' in poc_code,
            '// func(' in poc_code,
        ])

        if commented_trigger:
            notes.append("Trigger code is commented out (safe mode)")

        return ValidationResult(
            status=ValidationStatus.SUCCESS,
            poc_file='<string>',
            notes=notes
        )

    def validate_dynamic(self, poc_file: str,
                          timeout: int = 30,
                          capture_crash: bool = True) -> ValidationResult:
        """
        动态验证 PoC (在沙箱中执行)

        Args:
            poc_file: PoC 文件路径
            timeout: 超时秒数
            capture_crash: 是否捕获崩溃信息

        Returns:
            ValidationResult
        """
        import time

        if not self.sandbox_enabled:
            return ValidationResult(
                status=ValidationStatus.SKIPPED,
                poc_file=poc_file,
                notes=["Dynamic validation disabled"]
            )

        if not os.path.exists(poc_file):
            return ValidationResult(
                status=ValidationStatus.ERROR,
                poc_file=poc_file,
                notes=["PoC file not found"]
            )

        start_time = time.time()
        result = ValidationResult(poc_file=poc_file, status=ValidationStatus.NO_CRASH)

        try:
            # 确定解释器
            if poc_file.endswith('.py'):
                cmd = ['python', poc_file]
            elif poc_file.endswith('.exe'):
                cmd = [poc_file]
            else:
                result.status = ValidationStatus.ERROR
                result.notes.append("Unknown file type")
                return result

            # 在子进程中运行
            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if os.name == 'nt' else 0
            )

            try:
                stdout, stderr = proc.communicate(timeout=timeout)
                result.stdout = stdout.decode('utf-8', errors='replace')
                result.stderr = stderr.decode('utf-8', errors='replace')

                # 分析返回码
                return_code = proc.returncode

                if return_code == 0:
                    result.status = ValidationStatus.NO_CRASH
                    result.notes.append("Process exited normally")
                elif return_code < 0 or return_code > 0x80000000:
                    # 可能是异常代码
                    result.status = ValidationStatus.CRASH
                    result.exception_code = return_code if return_code > 0 else -return_code

                    # 查找异常类型
                    exc_info = self.EXCEPTION_CODES.get(result.exception_code)
                    if exc_info:
                        result.notes.append(f"Exception: {exc_info[0]}")
                        result.crash_type = exc_info[1]
                    else:
                        result.notes.append(f"Exception code: 0x{result.exception_code:x}")
                        result.crash_type = CrashType.UNKNOWN
                else:
                    result.status = ValidationStatus.NO_CRASH
                    result.notes.append(f"Exit code: {return_code}")

                # 解析 PoC 输出中的误报分析结果
                self._parse_false_positive_analysis(result)

            except subprocess.TimeoutExpired:
                proc.kill()
                result.status = ValidationStatus.TIMEOUT
                result.notes.append(f"Timed out after {timeout}s")

        except Exception as e:
            result.status = ValidationStatus.ERROR
            result.notes.append(f"Error: {e}")

        result.execution_time = time.time() - start_time
        self.validation_history.append(result)

        return result

    def _parse_false_positive_analysis(self, result: ValidationResult) -> None:
        """
        解析 PoC 输出中的误报分析结果

        PoC 模板会在崩溃时输出 [ANALYSIS_JSON]{...}[/ANALYSIS_JSON] 格式的分析结果
        """
        import re
        import json

        # 合并 stdout 和 stderr 搜索
        combined_output = (result.stdout or '') + (result.stderr or '')

        # 查找 ANALYSIS_JSON 标记
        match = re.search(r'\[ANALYSIS_JSON\](.*?)\[/ANALYSIS_JSON\]', combined_output, re.DOTALL)
        if not match:
            return

        try:
            analysis = json.loads(match.group(1))

            # 提取误报信息
            if analysis.get('is_false_positive'):
                result.is_false_positive = True
                result.false_positive_reason = analysis.get('reason', 'unknown')
                result.notes.append(f"[FALSE POSITIVE] {result.false_positive_reason}")

                # 获取崩溃地址和匹配的参数值
                if analysis.get('crash_address'):
                    result.crash_address = analysis['crash_address']
                if analysis.get('matched_arg_value'):
                    result.matched_arg_value = analysis['matched_arg_value']
                    result.notes.append(
                        f"Crash address matches passed argument: 0x{result.matched_arg_value:X}"
                    )
            else:
                # 不是误报
                if analysis.get('crash_address'):
                    result.crash_address = analysis['crash_address']
                result.notes.append("Crash analysis: genuine crash (not a signature error)")

        except (json.JSONDecodeError, KeyError, TypeError) as e:
            logger.debug(f"Failed to parse ANALYSIS_JSON: {e}")

    def create_test_harness(self, poc_code: str,
                             output_dir: str = None) -> str:
        """
        创建测试 harness

        Args:
            poc_code: PoC 代码
            output_dir: 输出目录

        Returns:
            Harness 文件路径
        """
        if output_dir is None:
            output_dir = tempfile.mkdtemp(prefix='luodllhack_poc_')

        harness_code = f'''#!/usr/bin/env python3
"""
LuoDllHack PoC Test Harness
"""
import sys
import traceback

def run_poc():
    try:
        # Original PoC code
{self._indent(poc_code, 8)}

        return 0
    except Exception as e:
        print(f"[!] Exception: {{e}}")
        traceback.print_exc()
        return 1

if __name__ == "__main__":
    sys.exit(run_poc())
'''

        harness_path = os.path.join(output_dir, 'poc_harness.py')
        with open(harness_path, 'w') as f:
            f.write(harness_code)

        return harness_path

    def _indent(self, code: str, spaces: int) -> str:
        """缩进代码"""
        indent = ' ' * spaces
        lines = code.split('\n')
        return '\n'.join(indent + line for line in lines)

    def analyze_crash(self, crash_dump: bytes) -> Dict:
        """
        分析崩溃转储

        Args:
            crash_dump: 崩溃转储数据

        Returns:
            分析结果
        """
        # 简化的崩溃分析
        analysis = {
            'exploitable': False,
            'crash_type': 'UNKNOWN',
            'control_of': [],
            'notes': []
        }

        dump_str = crash_dump.decode('utf-8', errors='replace')

        # 检查是否控制了关键寄存器
        control_patterns = [
            ('rip=41414141', 'RIP'),
            ('eip=41414141', 'EIP'),
            ('rsp=', 'RSP'),
            ('esp=', 'ESP'),
        ]

        for pattern, reg in control_patterns:
            if pattern in dump_str.lower():
                analysis['control_of'].append(reg)
                analysis['exploitable'] = True
                analysis['notes'].append(f"Controlled {reg}")

        # 检查崩溃类型
        if 'access violation' in dump_str.lower():
            analysis['crash_type'] = 'ACCESS_VIOLATION'
        elif 'stack overflow' in dump_str.lower():
            analysis['crash_type'] = 'STACK_OVERFLOW'
        elif 'heap corruption' in dump_str.lower():
            analysis['crash_type'] = 'HEAP_CORRUPTION'

        return analysis

    def get_validation_summary(self) -> Dict:
        """获取验证摘要"""
        total = len(self.validation_history)
        if total == 0:
            return {'total': 0}

        by_status = {}
        for result in self.validation_history:
            status = result.status.name
            by_status[status] = by_status.get(status, 0) + 1

        return {
            'total': total,
            'by_status': by_status,
            'crash_rate': by_status.get('CRASH', 0) / total * 100
        }

    def clear_history(self):
        """清空验证历史"""
        self.validation_history.clear()
